
\chapter{Logic and quantifiers 逻辑与量词}
\label{ch:logic}

{\em If at first you don't succeed, try again.  Then quit.
There's no use being a damn fool about it. --W.\ C.\ Fields}

{\em 如果一开始你没有成功，再试一次。然后放弃。没有必要为此做一个十足的傻瓜。——W. C. 菲尔兹}

\section{Predicates and Logical Connectives 谓词与逻辑联结词}
\label{sec:pred}

In every branch of Mathematics there are special, \index{atomic concepts}
atomic, notions that
defy precise definition.

在数学的每一个分支中，都有一些特殊的、\index{atomic concepts}原子的概念，它们无法被精确定义。

In Geometry, for example, the atomic notions
are points, lines and their incidence.

例如，在几何学中，原子的概念是点、线及其关联关系。

Euclid defines a point as
``that which has no part'' -- people can argue (and have argued) incessantly
over what exactly is meant by this.

欧几里得将点定义为“没有部分的东西”——人们可以（并且已经）为这句话的确切含义争论不休。

Is it essentially saying that anything 
without volume, area or length of some sort is a point?

这本质上是说任何没有体积、面积或某种长度的东西都是点吗？

In modern times
it has been recognized that any formal system of argumentation has to
have such elemental, undefined, concepts -- and that Euclid's apparent
lapse in precision comes from an attempt to hide this basic fact.

在现代，人们已经认识到，任何形式化的论证系统都必须有这样一些基本的、未定义的概念——而欧几里得在精确性上的明显失误，正源于他试图掩盖这一基本事实。

The notion of ``point'' can't really {\em be} defined.  All we can do
is point (no joke intended) at a variety of points and hope that our
audience will absorb the same concept of point that we hold via the 
process of \index{induction}induction\footnote{inference of a %
generalized conclusion from particular instances -- compare DEDUCTION. }.

“点”的概念实际上无法被{\em 定义}。我们所能做的就是指向（没有双关的意思）各种各样的点，并希望我们的听众能通过\index{induction}归纳\footnote{从特定实例中推断出普遍性结论的过程——与演绎法（DEDUCTION）相对比。}的过程，吸收我们所持有的点的概念。

The atomic concepts in Set Theory are ``set'', ``element'' and ``membership''.

集合论中的原子概念是“集合”、“元素”和“隶属关系”。

The atomic concepts in Logic are ``true'', ``false'', \index{sentence} 
``sentence'' and \index{statement} ``statement''.

逻辑学中的原子概念是“真”、“假”、\index{sentence}“句子”和\index{statement}“命题”。

Regarding {\em true} and {\em false}, we hope there is no uncertainty
as to their meanings.

关于{\em 真}和{\em 假}，我们希望它们的含义没有不确定性。

{\em Sentence} also has a well-understood
meaning that most will agree on -- a syntactically correct ordered collection
of words such as ``Johnny was a football player.'' or ``Red is a color.''
or ``This is a sentence which does not refer to itself.''  A {\em statement}
is a sentence which is either true or false.

{\em 句子}也有一个被广泛理解的含义，大多数人都会同意——即一个语法正确的有序词语集合，例如“约翰尼是一名足球运动员。”或“红色是一种颜色。”或“这是一个不指代自身的句子。”一个{\em 命题}是一个或真或假的句子。

In other words, a statement
is a sentence whose truth value is {\em definite}, in more other words,
it is always possible to decide -- one way or the other -- whether
a statement is true or false.\footnote{Although, as a practical matter
it may be almost impossibly difficult to do so!
For instance it is 
certainly either true or false that I ate eggs for breakfast on my 21st
birthday -- but I don't remember, and short of building a time machine,
I don't know how you could find out. }   The first example
of a sentence given above (``Johnny was a football player'') is not a 
statement -- the problem is that it is ambiguous unless we know who
Johnny is.

换句话说，命题是一个其真值是{\em 确定}的句子，再换句话说，总是有可能——以某种方式——决定一个命题是真是假。\footnote{尽管在实践中，这可能极其困难！例如，我在21岁生日那天早餐是否吃了鸡蛋这件事，肯定是或真或假的——但我不记得了，而且除非造一台时间机器，否则我不知道你怎么能查出来。}上面给出的第一个句子例子（“约翰尼是一名足球运动员”）不是一个命题——问题在于，除非我们知道约翰尼是谁，否则它是模糊的。

If it had said ``Johnny Unitas was a football player.'' then
it would have been a statement.

如果它说的是“约翰尼·尤尼塔斯是一名足球运动员。”那么它就是一个命题。

If it had said ``Johnny Appleseed was a 
football player.'' it would also have been a statement, just not a true one.

如果它说的是“约翰尼·阿普尔西德是一名足球运动员。”那它也会是一个命题，只是一个假命题。

Ambiguity is only one reason that a sentence may not be a statement.

模糊性只是一个句子可能不是命题的其中一个原因。

As 
we consider more complex sentences, it may be the case that the truth
value of a given sentence simply cannot be decided.

当我们考虑更复杂的句子时，可能会出现一个给定句子的真值根本无法被决定的情况。

One of the most
celebrated mathematical results of the 20th century is 
\index{G\"{o}del, Kurt}Kurt G\"{o}del's
\index{Incompleteness Theorem}``Incompleteness Theorem.''  
An important aspect of this theory is 
the proof that in any axiomatic system of mathematical thought
there must be undecidable sentences -- statements which can neither be proved
nor disproved from the axioms\footnote{There are trivial systems that %
are complete, but if a system is sufficiently complicated that it contains %
``interesting'' statements it can't be complete. }.

20世纪最著名的数学成果之一是\index{G\"{o}del, Kurt}库尔特·哥德尔的\index{Incompleteness Theorem}“不完备性定理”。该理论的一个重要方面是证明了在任何数学思想的公理系统中，都必然存在不可判定的句子——即无法从公理中证明也无法证伪的命题\footnote{存在一些琐碎的完备系统，但如果一个系统足够复杂以至于包含了“有趣”的陈述，那么它就不可能是完备的。}。

Simple sentences (e.g.\ those of the form 
subject-verb-object) have little chance of being undecidable for this
reason, so we will next look at ways of building more complex sentences
from simple components.

因此，简单句（例如主-谓-宾形式的句子）因此而不可判定的可能性很小，所以我们接下来将探讨如何用简单的部分构建更复杂的句子。

Let's start with an example.  Suppose I come up to you in some windowless
room and make the statement: ``The sun is shining but it's raining!''  
You decide to investigate my claim and determine its veracity.

让我们从一个例子开始。假设我在某个没有窗户的房间里走到你面前，说：“太阳正照耀着，但天在下雨！”你决定去调查我的说法并确定其真实性。

Upon
reaching a room that has a view of the exterior there are four possible
combinations of sunniness and/or precipitation that you may find.

到达一个能看到外面的房间后，你可能会发现四种可能的晴天和/或降水的组合。

That is,
the atomic predicates ``The sun is shining'' and ``It is raining'' can each 
be true or false independently of one another.

也就是说，原子谓词“太阳正照耀着”和“天在下雨”可以各自独立地为真或为假。

In the following table 
we introduce a convention used throughout the remainder of this book -- 
that true is indicated with a capital letter T and false is indicated 
with the Greek letter $\phi$ (which is basically a Greek F, and is a lot harder
to mistake for a T than an F is.)

在下表中，我们介绍一个在本书其余部分都使用的约定——真用大写字母T表示，假用希腊字母$\phi$（基本上是希腊字母F，比F更不容易与T混淆）表示。

\begin{center}
\begin{tabular}{c|c}
The sun is shining \; & \; It is raining \\ \hline
T & T \\
T & $\phi$ \\
 $\phi$ & T \\
 $\phi$ &  $\phi$ \\
\end{tabular}
\end{center}

Each row of the above table represents a possible state of the outside 
world.

上表的每一行代表了外部世界的一种可能状态。

Suppose you observe the conditions given in the last row, namely
that it is neither sunny, nor is it raining -- you would certainly conclude
that I am not to be trusted.

假设你观察到最后一行给出的情况，即既没有出太阳，也没有下雨——你肯定会得出结论，认为我是不可信的。

I.e.\ my statement, the compounding of 
``The sun is shining'' and ``It is raining'' (with the word ``but'' in between
as a connector) is false.

也就是说，我的陈述，即“太阳正照耀着”和“天在下雨”的复合句（中间用“但是”作为连接词）是假的。

If you think about it a bit, you'll agree that
this so-called \index{compound sentence}{\em compound sentence} is true 
only in the case that both
of its component pieces are true.

如果你稍微想一下，你会同意这个所谓的\index{compound sentence}{\em 复合句}只有在它的两个组成部分都为真时才为真。

This underscores an amusing linguistic
point: ``but'' and ``and'' have exactly the same meaning!

这凸显了一个有趣的语言学观点：“但是”和“并且”的含义完全相同！

More precisely,
they {\em denote} the same thing, they have subtly different connotations
however -- ``but'' indicates that both of the statements it connects
are true and that the speaker is surprised by this state of affairs.

更准确地说，它们{\em 指代}相同的事物，但它们有微妙不同的内涵——“但是”表示它连接的两个陈述都为真，并且说话者对这种情况感到惊讶。

In Mathematics we distinguish two main connectives for hooking-up simple
sentences into compound ones.

在数学中，我们区分两种主要的连接词，用于将简单句连接成复合句。

The \index{conjunction}{\em conjunction} 
of two sentences is
the compound sentence made by sticking the word ``and'' between them.

两个句子的\index{conjunction}{\em 合取}是通过在它们之间加上“并且”这个词构成的复合句。

The \index{disjunction}{\em disjunction} of two sentences is 
formed by placing an ``or'' 
between them.

两个句子的\index{disjunction}{\em 析取}是通过在它们之间加上“或者”形成的。

Conjunctions are true only when both components are true.
Disjunctions are false only when both components are false.

合取仅在两个组成部分都为真时为真。析取仅在两个组成部分都为假时为假。

As usual, mathematicians have developed an incredibly terse, compact
notation for these ideas.\footnote{One begins to suspect that %
mathematicians form an unusually lazy sub-species of humanity. }  
First, we represent an
entire sentence by a single letter -- traditionally, a capital letter.

像往常一样，数学家为这些思想发展出了一种极其简洁、紧凑的符号。\footnote{人们开始怀疑数学家是人类中一个异常懒惰的亚种。}首先，我们用一个单独的字母——传统上是一个大写字母——来代表整个句子。

This is called a \index{predicate variable}{\em predicate variable}.
For example, following the example above, we could denote the sentence
``The sun is shining'' by the letter $S$.

这被称为\index{predicate variable}{\em 谓词变量}。例如，沿用上面的例子，我们可以用字母$S$来表示句子“太阳正照耀着”。

Similarly, we could make the
assignment $R =$ ``It is raining.''   The conjunction and disjunction 
of these sentences can then be represented using the symbols $S \land R$
and $S \lor R$, respectively.

同样，我们可以赋值$R=$“天在下雨。”这些句子的合取和析取就可以分别用符号$S \land R$和$S \lor R$来表示。

As a mnemonic, note that the connective
in $S \land R$ looks very much like the capital letter A (as in And).

作为一个助记符，请注意$S \land R$中的联结词看起来很像大写字母A（代表And）。

To display, very succinctly, the effect of these two connectives we can
use so-called \index{truth table}truth tables.

为了非常简洁地展示这两个联结词的效果，我们可以使用所谓的\index{truth table}真值表。

In a truth table we list 
all possible truth 
values of the predicate variables and then enumerate the truth values 
of some compound sentence.

在真值表中，我们列出谓词变量所有可能的真值，然后列举某个复合句的真值。

For the conjunction and disjunction
connectors we have (respectively):

对于合取和析取联结词，我们分别有：

\begin{center}
\begin{tabular}{c|c||c}
\; $A$ \; & \; $B$ \; & \; $A \land B$ \; \\ \hline
T & T & T \\
T & $\phi$ & $\phi$\\
 $\phi$ & T & $\phi$\\
 $\phi$ &  $\phi$ & $\phi$\\
\end{tabular}
\hspace{.25in}and\hspace{.25in}
\begin{tabular}{c|c||c}
\; $A$ \; & \; $B$ \; & \; $A \lor B$ \; \\ \hline
T & T & T \\
T & $\phi$ & T\\
 $\phi$ & T & T\\
 $\phi$ &  $\phi$ & $\phi$\\
\end{tabular}.
\end{center}

In addition to these connectors we need a modifier (called 
\index{negation}{\em negation}) 
that acts on individual sentences.

除了这些联结词，我们还需要一个作用于单个句子的修饰词（称为\index{negation}{\em 否定}）。

The negation of a sentence $A$ is 
denoted by ${\lnot}A$, and its truth value is exactly the opposite of
$A$'s truth value.

句子$A$的否定记为${\lnot}A$，其真值与$A$的真值正好相反。

The negation of a sentence is also known as the
\emph{denial} of a sentence.

一个句子的否定也被称为该句子的\emph{denial}。

A truth table for the negation operator is somewhat 
trivial but we include it here for completeness.

否定算子的真值表有些琐碎，但为了完整性，我们在此列出。

\begin{center}
\begin{tabular}{c||c}
\; $A$ \; &  \; ${\lnot}A$ \; \\ \hline
 T & $\phi$ \\
 $\phi$ & T \\
\end{tabular}
\end{center}

These three simple tools (and, or \& not) are sufficient to 
create extraordinarily complex sentences out of basic components.

这三个简单的工具（与、或、非）足以从基本部分创造出极其复杂的句子。

The way these pieces interrelate is a bit reminiscent of algebra,
in fact the study of these logical operators (or any
 operators that act like them) is called \index{Boole, George}
 {\em Boolean Algebra}\footnote{In honor of George Boole, whose 1854 %
 book {\em An investigation into the Laws of Thought} inaugurated the %
 subject. }.

这些部分相互关联的方式有点让人想起代数，事实上，对这些逻辑运算符（或任何类似它们的运算符）的研究被称为\index{Boole, George}{\em 布尔代数}\footnote{为纪念乔治·布尔，他1854年的著作《思想规律的研究》开创了这一学科。}。

There are distinct differences
between Boolean and ordinary algebra however.  In regular algebra we have
the binary connectors $+$ (plus) and $\cdot$ (times), and the unary 
negation operator $-$, these are certainly analogous to $\land$, $\lor$ \&
$\lnot$, but there are certain consequences of the fact that multiplication
is effectively repeated addition that simply don't hold for the Boolean
operators.

然而，布尔代数和普通代数之间存在明显的差异。在常规代数中，我们有二元联结词+（加）和·（乘），以及一元否定算子-，这些当然与$\land$、$\lor$和$\lnot$类似，但是乘法实际上是重复加法这一事实所带来的一些后果，对于布尔运算符来说根本不成立。

For example, there is a well-defined precedence between $\cdot$ and
$+$.

例如，·和+之间有明确定义的优先级。

In parsing the expression $4 \cdot 5 + 3$ we all know that the 
multiplication is to be done first.

在解析表达式$4 \cdot 5 + 3$时，我们都知道要先做乘法。

There is no such rule governing
order of operations between $\land$ and $\lor$, so an expression like
$A \land B \lor C$ is simply ambiguous -- it {\em must} have parentheses
inserted in order to show the order, either  $(A \land B) \lor C$ or 
$A \land (B \lor C)$.

$\land$和$\lor$之间没有这样的运算顺序规则，所以像$A \land B \lor C$这样的表达式是模糊的——它{\em 必须}插入括号以显示顺序，要么是$(A \land B) \lor C$，要么是$A \land (B \lor C)$。

Another distinction between ordinary and Boolean
algebra is exponentiation.  If there {\em were} exponents in Boolean algebra,
we'd need two different kinds -- one for repeated conjunction and another
for repeated disjunction.

普通代数和布尔代数之间的另一个区别是指数运算。如果布尔代数中{\em 有}指数，我们将需要两种不同的指数——一种用于重复合取，另一种用于重复析取。

\begin{exer} 
Why is it that there is no such thing as exponentiation
in the algebra of Logic?

为什么逻辑代数中没有指数运算这样的东西？
\end{exer}

While there are many differences between Boolean algebra and the
usual, garden-variety algebra, there are also many similarities.

虽然布尔代数和通常的普通代数之间有许多不同之处，但也有许多相似之处。

For instance, the \index{associative law}associative, 
\index{commutative law}commutative and 
\index{distributive law}distributive laws
of Algebra all have versions that work in the Boolean case.

例如，代数中的\index{associative law}结合律、\index{commutative law}交换律和\index{distributive law}分配律在布尔情况下都有对应的版本。

A very handy way of visualizing Boolean expressions is given by
digital logic circuit diagrams.

一种非常方便的可视化布尔表达式的方法是使用数字逻辑电路图。

To discuss these diagrams we 
must make a brief digression into Electronics.

为了讨论这些图，我们必须简单地跑一下题，谈谈电子学。

One of the most
basic components inside an electronic device is a \index{transistor}
transistor,
this is a component that acts like a switch for electricity,
but the switch itself is controlled by electricity.

电子设备中最基本的元件之一是\index{transistor}晶体管，它是一种像电开关一样的元件，但这个开关本身是由电控制的。

In Figure~\ref{fig:trans}
we see the usual schematic representation of a transistor.

在图~\ref{fig:trans}中，我们看到了晶体管的常规示意图。

If voltage
is applied to the wire labeled z, the transistor becomes conductive,
and current may flow from x to y.

如果向标记为z的导线施加电压，晶体管就会导电，电流就可以从x流向y。

\begin{figure}[!hbtp] 
\begin{center}
\input{figures/transistor.tex}
\end{center}
\caption{A schematic representation of a transistor. 晶体管的示意图。}
\label{fig:trans}
\end{figure}

Suppose that two transistors are connected as in Figure~\ref{fig:series}
(this is called a \index{series connection}{\em series} connection).

假设两个晶体管如图~\ref{fig:series}所示连接（这被称为\index{series connection}{\em 串联}）。

In order for current to flow
from x to y we must have voltage applied to {\em both} the wires labeled
z and w.

为了让电流从x流到y，我们必须向标记为z和w的导线{\em 都}施加电压。

In other words, this circuit effectively creates the {\bf and} 
operation --  assuming voltage is always applied to x, if z {\bf and} w
are energized then the output at y will be energized.

换句话说，这个电路有效地创造了{\bf 与}运算——假设电压总是施加到x，如果z{\bf 和}w都被激活，那么y端的输出也将被激活。

\begin{figure}[!hbtp] 
\begin{center}
\input{figures/series.tex}
\end{center}
\caption[Series connections implement \emph{and}.串联连接实现了{\em 与}。]{%
The connection of two transistors in series provides %
an implementation of the {\em and} operator. 两个晶体管的串联连接实现了{\em 与}运算符。}
\label{fig:series}
\end{figure}

When two transistors are connected in \index{parallel connection}parallel (this is illustrated in
Figure~\ref{fig:par}) current can flow from x to y when either (or {\em both})
of the wires at z and w have voltage applied.

当两个晶体管\index{parallel connection}并联（如图~\ref{fig:par}所示）时，当z和w两根导线中的任意一根（或{\em 两根}）施加电压时，电流就可以从x流到y。

This brings up a point
which is confusing for some: in common speech the use of the word ``or'' often
has the sense known as \index{exclusive or}{\em exclusive or} (a.k.a.\ xor), when we say ``X or Y''
we mean ``Either X or Y, but not both.''  In Electronics and Mathematics,
{\em or} always has the non-exclusive (better known as 
\index{inclusive or}inclusive) sense.

这就引出了一个对某些人来说会感到困惑的问题：在日常用语中，“或”这个词的使用通常具有\index{exclusive or}{\em 异或}（也叫xor）的意义，当我们说“X或Y”时，我们指的是“要么X，要么Y，但不能两者都是。”而在电子学和数学中，{\em 或}总是具有非排他性的（更广为人知的是\index{inclusive or}相容的）意义。

\begin{figure}[!hbtp] 
\begin{center}
\input{figures/parallel.tex}
\end{center}
\caption[Parallel connections implement \emph{or}.并联连接实现了{\em 或}]{%
The connection of two transistors in parallel provides %
an implementation of the {\em or} operator. 两个晶体管的并联连接实现了{\em 或}运算符。}
\label{fig:par}
\end{figure}

\newpage

As a sort of \index{logic gates}graphical shorthand, electronics engineers use the symbols
below to indicate \index{and gates}and-gates, \index{or gates}or-gates \& \index{not gates}not-gates (better known as negators).

作为一种\index{logic gates}图形化的简写方式，电子工程师使用下面的符号来表示\index{and gates}与门、\index{or gates}或门和\index{not gates}非门（更广为人知的是反相器）。

\begin{center}
\input{figures/gates.tex}
\end{center}

An and-gate has two transistors inside it that are wired in series -- 
if both the inputs are energized the output will be too.

一个与门内部有两个串联的晶体管——如果两个输入都被激活，输出也会被激活。

An
or-gate has two transistors in parallel inside it.  Not-gates 
involve magic -- when their input is not on, their output \emph{is}
and vice versa.

一个或门内部有两个并联的晶体管。非门则涉及魔术——当它的输入没有信号时，它的输出\emph{有}信号，反之亦然。

Using this graphical ``language'' one can make schematic 
representations of logical expressions.

使用这种图形化的“语言”，可以制作逻辑表达式的示意图。

Some find that 
tracing such diagrams makes understanding the structure 
of a Boolean expression easier.

有些人发现，追踪这样的图表能让理解布尔表达式的结构变得更容易。

For example, in Figure~\ref{fig:3ands}
we illustrate 2 of the possible ways that the conjunction
of four predicate variables can be parenthesized.

例如，在图~\ref{fig:3ands}中，我们展示了四个谓词变量合取的两种可能的括号组合方式。

In fact, when
a multitude of predicates are joined by the same connective,
the way in which the expression is parenthesized is unimportant,
thus one often sees a further shorthand --- gates with more than
2 inputs.

事实上，当多个谓词由同一个联结词连接时，表达式的括号方式并不重要，因此人们常常看到一种更进一步的简写——多于两个输入的门。

\begin{figure}[!hbtp] 
\centerline{\input{figures/3_ands.tex}}
\caption[Parenthesizations expressed as digital logic circuits.用数字逻辑电路表示括号方式]{%
Two of the possible ways to parenthesize the conjunction %
of four statement variables -- expressed as digital logic circuits. 四个命题变量合取的两种可能的括号方式——用数字逻辑电路表示。}
\label{fig:3ands}
\end{figure}

A common task for an electronics designer is to come up with
a digital logic circuit having a prescribed input/output table.

电子设计师的一项常见任务是设计一个具有规定输入/输出表的数字逻辑电路。

Note that an input/output table for a logic circuit is entirely
analogous with a truth table for a compound sentence in Logic ---
except that we use 0's and 1's rather than T's and $\phi$'s.

请注意，逻辑电路的输入/输出表与逻辑学中复合句的真值表是完全类似的——只是我们用0和1，而不是T和$\phi$。

Suppose that we wanted to design a circuit that would
have the following input/output table.

假设我们想设计一个具有以下输入/输出表的电路。

\begin{center}
\begin{tabular}{c|c|c|c}
$\; x \;$ & $\; y \;$ & $\; z \;$ & \rule{5pt}{0pt} out \rule{5pt}{0pt} \\ \hline
0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 1 & 1 & 1 \\ \hline
1 & 0 & 0 & 0 \\ 
1 & 0 & 1 & 0 \\ 
1 & 1 & 0 & 1 \\ 
1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

A systematic method for accomplishing such a design task involves
a notion called \index{disjunctive normal form}{\em disjunctive normal form}.

完成此类设计任务的一个系统性方法涉及一个叫做\index{disjunctive normal form}{\em 析取范式}的概念。

A Boolean expression
is in disjunctive normal form if it consists of the disjunction of 
one or more statements, each of which consists entirely of conjunctions
of predicate variables and/or their negations.

如果一个布尔表达式由一个或多个命题的析取组成，而其中每个命题又完全由谓词变量和/或其否定的合取组成，则该表达式处于析取范式。

In other words, the {\em or}
of a bunch of {\em ands}.

换句话说，就是一堆{\em 与}运算的{\em 或}运算。

In terms of digital logic circuits, the {\em and}s 
we're talking about are called \index{recognizers}{\em recognizers}.

就数字逻辑电路而言，我们所说的{\em 与}门被称为\index{recognizers}{\em 识别器}。

For example,
the following 3-input and-gates recognize the input states in
the 4th, 7th and 8th rows of the i/o table above.

例如，以下3输入与门识别了上面输入/输出表第4、7和8行的输入状态。

(These are the rows 
where the output is supposed to be 1.)

（这些是输出应该为1的行。）

\begin{center}
\input{figures/recognizers.tex}
\end{center}

In Figure~\ref{fig:dnf} we illustrate how to create a circuit whose
i/o table is as above using these recognizers.

在图~\ref{fig:dnf}中，我们展示了如何使用这些识别器来创建一个其输入/输出表如上所述的电路。

\begin{figure}[!hbtp] 
\begin{center}
\input{figures/logic_circuit.tex}
\end{center}
\caption[Disjunctive normal form.析取范式]{A digital logic circuit built % 
using disjunctive normal form.
The output of this circuit is %
$({\lnot}x \land y \land z) \lor (x \land y \land {\lnot}z) \lor (x \land y \land z)$. 使用析取范式构建的数字逻辑电路。该电路的输出是 $({\lnot}x \land y \land z) \lor (x \land y \land {\lnot}z) \lor (x \land y \land z)$。}
\label{fig:dnf}
\end{figure}

\newpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/pred-exer.tex}

\newpage

\section{Implication 蕴涵}
\label{sec:impl}

Suppose a mother makes the following statement to her child:
``If you finish your peas, you'll get dessert.''

假设一位母亲对她的孩子说：“如果你吃完豌豆，你就会得到甜点。”

This is a compound sentence made up of the two simpler
sentences $P=$ ``You finish your peas'' and $D=$ ``You'll get dessert.''
It is an example of a type of compound sentence called a 
\index{conditional statement}{\em conditional}.

这是一个由两个更简单的句子组成的复合句：$P=$“你吃完豌豆”和$D=$“你会得到甜点。”它是一种叫做\index{conditional statement}{\em 条件句}的复合句的例子。

Conditionals are if-then type statements.  
In ordinary language the word ``then'' is often elided (as is the case
with our example above).

条件句是“如果-那么”类型的陈述。在日常语言中，“那么”这个词经常被省略（就像我们上面的例子一样）。

Another way of phrasing the ``If P then D.'' 
relationship is to use the word ``implies'' --- although it would be
a rather uncommon mother who would say ``Finishing your peas implies
that you will receive dessert.'' 

表达“如果P那么D”关系的另一种方式是使用“蕴涵”这个词——尽管很少有母亲会说“吃完你的豌豆蕴涵着你将得到甜点。”

As was the case in the previous section, there are four possible
situations and we must consider each to decide the truth/falsity 
of this conditional statement.

和上一节的情况一样，有四种可能的情况，我们必须考虑每一种情况来决定这个条件陈述的真假。

The peas may or may not be finished,
and independently, the dessert may or may not be proffered.

豌豆可能吃完，也可能没吃完；与此独立地，甜点可能给，也可能不给。

Suppose the child finishes the peas and the mother comes across
with the dessert.

假设孩子吃完了豌豆，母亲也给了甜点。

Clearly, in this situation the mother's statement 
was true.  On the other hand, if the child finishes the hated peas
and yet does not receive a treat, it is just as obvious that the 
mother has lied!

显然，在这种情况下，母亲的陈述是真的。另一方面，如果孩子吃完了讨厌的豌豆却没有得到奖励，那么同样明显，母亲撒谎了！

What do we say about the mother's veracity in the case that the peas
go unfinished?  Here, Mom gets a break.

如果豌豆没吃完，我们该如何评价母亲的诚实度呢？在这里，妈妈可以松一口气。

She can either hold firm
and deliver no dessert, or she can be a softy and give out unearned 
sweets -- in either case, we can't accuse her of telling a falsehood.

她可以坚持不给甜点，也可以心软送出本不该得的糖果——无论哪种情况，我们都不能指责她说了假话。

The statement she made had to do {\em only} with the eventualities
following total pea consumption, she said nothing about what happens
if the peas go uneaten.

她所做的陈述{\em 只}与吃完所有豌豆之后的情况有关，她没有说如果豌豆没吃会发生什么。

A conditional statement's components are called the 
\index{antecedent}{\em antecedent} 
(this is the ``if'' part, as in ``finish
your peas'') and the \index{consequent}{\em consequent} (this is the ``then'' part, as in
``get dessert'').

条件陈述的组成部分被称为\index{antecedent}{\em 前件}（即“如果”部分，如“吃完你的豌豆”）和\index{consequent}{\em 后件}（即“那么”部分，如“得到甜点”）。

The discussion in the 
last paragraph was intended to make the point that when the antecedent
is false, we should consider the conditional to be true.

上一段的讨论旨在说明，当前件为假时，我们应认为条件句为真。

Conditionals
that are true because their antecedents are false are said to
be \index{vacuous truth}{\em vacuously true}.

因前件为假而为真的条件句被称为\index{vacuous truth}{\em 善意推定为真}。

The conditional 
involving an antecedent $A$
and a consequent $B$ is expressed symbolically using an arrow: 
$A \implies B$.

涉及前件$A$和后件$B$的条件句用箭头符号表示：$A \implies B$。

Here is a truth table for this connective.

这是该联结词的真值表。

\begin{center}
\begin{tabular}{c|c||c}
\; $A$ \; & \; $B$ \; & \; $A \implies B$ \; \\ \hline
T & T & T \\
T & $\phi$ & $\phi$\\
 $\phi$ & T & T \\
 $\phi$ &  $\phi$ & T\\
\end{tabular}
\end{center}

\begin{exer} 
Note that this truth table is similar to the truth table for
$A \lor B$ in that there is only a single row having a $\phi$ in
the last column.

请注意，这个真值表与$A \lor B$的真值表相似，因为最后一列只有一个$\phi$。

For $A \lor B$ the $\phi$ occurs in the 4th row
and for $A \implies B$ it occurs in the 2nd row.

对于$A \lor B$，$\phi$出现在第4行；对于$A \implies B$，它出现在第2行。

This suggests
that by suitably modifying things (replacing $A$ or $B$ by their
negations) we could come up with an ``or'' statement that had the 
same meaning as the conditional.

这表明，通过适当修改（用它们的否定替换$A$或$B$），我们可以得出一个与条件句具有相同含义的“或”陈述。

Try it!

试试看！
\end{exer}

It is fairly common that conditionals are used to express threats,
as in the peas/dessert example.

条件句通常用来表达威胁，就像豌豆/甜点的例子一样。

Another common way to express a 
threat is to use a disjunction -- ``Finish your peas, or you won't
get dessert.''  If you've been paying attention (and did the last
exercise), you will notice that this is {\em  not} the disjunction
that should have the same meaning as the original conditional.

表达威胁的另一种常见方式是使用析取——“吃完你的豌豆，否则你得不到甜点。”如果你一直有在注意（并且做了上一个练习），你会发现这{\em 不}是那个应该与原始条件句具有相同含义的析取。

There is probably no mother on Earth who would say
``Don't finish your peas, or you get dessert!'' to her child
(certainly not if she expects to be understood).

地球上大概没有哪个母亲会对她的孩子说“不要吃完你的豌豆，或者你得到甜点！”（当然，如果她期望被理解的话）。

So what's going on
here?

那么，这里发生了什么？

The problem is that ``Finish your peas, or you won't
get dessert.'' has the same logical content as
``If you get dessert then you finished your peas.''
(Notice that the roles of the antecedent and consequent have been
switched.)  And, while this last sentence sounds awkward, it is
probably a more accurate reflection of what the mother intended.

问题在于，“吃完你的豌豆，否则你得不到甜点”与“如果你得到甜点，那么你吃完了豌豆”具有相同的逻辑内容。（请注意，前件和后件的角色已经互换了。）而且，尽管最后一句话听起来很别扭，但它可能更准确地反映了母亲的意图。

The problem {\em really} is that people are incredibly sloppy 
with their conditional statements!

问题{\em 真正}在于人们在使用条件陈述时极其草率！

A lot of people secretly want 
the 3rd row of the truth table for $\implies$ to have a $\phi$
in it, and it simply doesn't!

很多人私下里希望$\implies$真值表的第三行有一个$\phi$，但它根本没有！

The operator that results if we do
make this modification is called the \index{biconditional}
biconditional, and is expressed
in English using the phrase ``if and only if'' (which leads mathematicians
to the abbreviation \index{iff}``iff'' much to the consternation of 
spell-checking programs everywhere).

如果我们确实做了这个修改，得到的运算符叫做\index{biconditional}双条件，在英语中用短语“当且仅当”表示（这导致数学家使用缩写\index{iff}“iff”，让各地的拼写检查程序大为懊恼）。

The biconditional is denoted 
using an arrow that points both ways.  Its truth table follows.

双条件用一个双向箭头表示。其真值表如下。

\begin{center}
\begin{tabular}{c|c||c}
\; $A$ \; & \; $B$ \; & \; $A \iff B$ \; \\ \hline
T & T & T \\
T & $\phi$ & $\phi$\\
 $\phi$ & T & $\phi$ \\
 $\phi$ &  $\phi$ & T\\
\end{tabular}
\end{center}

Please note, that while we like to strive for precision, we do not
necessarily recommend the use of phrases such as 
``You will receive dessert if, and only if,
you finish your peas.'' with young children.

请注意，虽然我们力求精确，但我们不一定推荐对幼儿使用诸如“你将得到甜点，当且仅当你吃完你的豌豆”之类的短语。

Since conditional sentences are often confused with the sentence
that has the roles of antecedent and consequent reversed, this
switched-around sentence has been given a name: it is the 
\index{converse}{\em converse}
of the original statement.

由于条件句常常与前件和后件角色互换的句子相混淆，这个颠倒的句子被赋予了一个名字：它是原始陈述的\index{converse}{\em 逆命题}。

Another conditional that is distinct from 
(but related to) a given conditional is its \index{inverse}{\em inverse}.

另一个与给定条件句不同（但相关）的条件句是它的\index{inverse}{\em 否命题}。

This sort of sentence probably had to be named because of a very common 
misconception, many people think that the way to negate an if-then 
proposition is to negate
its parts.

这种句子可能之所以需要被命名，是因为一个非常普遍的误解，许多人认为否定一个“如果-那么”命题的方法是否定它的各个部分。

Algebraically, this looks reasonable -- sort of a distributive
law for logical negation over implications -- ${\lnot}( A \implies B) =
{\lnot}A \implies {\lnot}B$.

从代数上看，这似乎是合理的——有点像逻辑否定对蕴涵的分配律——${\lnot}( A \implies B) = {\lnot}A \implies {\lnot}B$。

Sadly, this reasonable looking assertion
can't possibly be true; since implications have just one $\phi$ in a truth 
table, the negation of an implication  must have three -- but the statement 
with the $\lnot$'s on the {\em parts} of the implication is going to only have 
a single $\phi$ in {\em its} truth table.

遗憾的是，这个看似合理的断言不可能是真的；因为蕴涵在真值表中只有一个$\phi$，所以蕴涵的否定必须有三个——但是那个在蕴涵的{\em 各个部分}上带有$\lnot$的陈述，在{\em 它}的真值表中将只有一个$\phi$。

To recap, the converse of an implication has the pieces (antecedent and 
consequent) switched about.

总而言之，一个蕴涵的逆命题是将其各个部分（前件和后件）互换。

The inverse of an implication has the 
pieces negated.  Neither of these is the same as the original implication.

一个蕴涵的否命题是将其各个部分否定。这两者都与原始蕴涵不同。

Oddly, this is one of those times when two wrongs {\em do} make a right.

奇怪的是，这是“两个错误{\em 能}构成一个正确”的时刻之一。

If you start with an implication, form its converse, then take the inverse
of that, you get a statement having exactly the same logical meaning
as the original.

如果你从一个蕴涵开始，构造它的逆命题，然后再取其否命题，你就会得到一个与原始蕴涵具有完全相同逻辑意义的陈述。

This new statement is called the 
\index{contrapositive}{\em contrapositive}.

这个新的陈述被称为\index{contrapositive}{\em 逆否命题}。

This information is displayed in Table~\ref{tab:contra} 

此信息显示在表~\ref{tab:contra}中。

\begin{table}[hbt] 
\begin{center}
\begin{tabular}{cc} 
 & converses (逆命题) \\
 & %
\ifx\pdfoutput\undefined % We're not running pdftex
 \includegraphics{figures/horiz_arrows.eps} \\%
\else
 \includegraphics{figures/horiz_arrows.pdf} \\%
\fi
\parbox[c]{10pt}{ \begin{sideways} inverses (否命题) \end{sideways} } 
\parbox[c]{10pt}{ 
\ifx\pdfoutput\undefined % We're not running pdftex
 \includegraphics{figures/vert_arrows.eps}% 
\else
\includegraphics{figures/vert_arrows.pdf}% 
\fi } & %
\begin{tabular}{|ccc|ccc|} \hline
 \rule{20pt}{0pt} & \rule{0pt}{20pt} & \rule{20pt}{0pt} & \rule{20pt}{0pt} & \rule{0pt}{20pt} & \rule{20pt}{0pt} \\
 & $A \implies B$ & & & $B \implies A$ & \\
 \rule{0pt}{20pt} & & & & & \\ \hline
 \rule{0pt}{20pt} & & & & & \\
 & ${\lnot}A \implies {\lnot}B$ & & & ${\lnot}B \implies {\lnot}A$ & \\ 

\rule{0pt}{20pt} & & & & & \\ \hline
\end{tabular} \\
\end{tabular}
\end{center}
\caption[Converse, inverse and contrapositive.逆命题、否命题和逆否命题]{The relationship %
between a conditional statement, its converse, its inverse and its %
contrapositive. 一个条件陈述及其逆命题、否命题和逆否命题之间的关系。}
\label{tab:contra}
\end{table}


One final piece of advice about conditionals: don't confuse logical
if-then relationships with causality.

关于条件句的最后一点建议：不要将逻辑上的如果-那么关系与因果关系混淆。

Many of the if-then sentences
we run into in ordinary life describe cause and effect:  
``If you cut the green wire the bomb will explode.''  (Okay, that one
is an example from the ordinary life of a bomb squad technician, but \ldots)
It is usually best to think of the if-then relationships we find in
Logic as divorced from the flow of time, the fact that $A \implies B$
is logically the same as ${\lnot}A \lor B$ lends credence to this point of view.

我们在日常生活中遇到的许多如果-那么句子描述的是因果关系：“如果你剪断绿色的线，炸弹就会爆炸。”（好吧，这是一个拆弹技术员日常生活中的例子，但是……）通常最好将我们在逻辑学中找到的如果-那么关系看作是与时间流逝无关的，事实$A \implies B$在逻辑上与${\lnot}A \lor B$相同，这为这一观点提供了支持。

\newpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/impl-exer.tex}

\newpage

\section{Logical equivalences 逻辑等价}
\label{sec:le}

Some logical statements are ``the same.''  For example, in the last
section, we discussed the fact that a conditional
and its contrapositive have the same logical content.

有些逻辑陈述是“相同”的。例如，在上一节中，我们讨论了一个条件句及其逆否命题具有相同的逻辑内容这一事实。

Wouldn't
we be justified in writing something like the following?

我们写下类似下面的东西难道没有道理吗？

\[ A \implies B \; = \; {\lnot}B \implies {\lnot}A \]

Well, one pretty serious objection to doing that is that the 
equals sign ($=$) has already got a job;
it is used to indicate that
two numerical quantities are the same.

嗯，一个相当严重的反对理由是，等号（$=$）已经有了一份工作；它被用来表示两个数值量是相同的。

What we're doing here is 
really sort of a different thing!

我们在这里所做的事情确实是另一回事！

Nevertheless, there is a concept
of ``sameness'' between certain compound statements, and we need a 
symbolic way of expressing it.

尽管如此，某些复合陈述之间存在“相同性”的概念，我们需要一种符号化的方式来表达它。

There are two notations in common 
use.  The notation that seems to be preferred by logicians is the
biconditional ($\iff$).

有两种常用的符号。逻辑学家似乎更喜欢双条件符号（$\iff$）。

The notation we'll use
in the rest of this book is an equals sign with a bit of extra decoration
on it ($\cong$).

在本书的其余部分，我们将使用的符号是一个带有一点额外装饰的等号（$\cong$）。

Thus we can can either write 

因此，我们可以写成

\[ (A \implies B) \; \iff \; ({\lnot}B \implies {\lnot}A) \]

\noindent or 

\noindent 或

\[ A \implies B \; \cong \; {\lnot}B \implies {\lnot}A. \]

\noindent I like the latter, but use whichever form you like -- no one
will have any problem understanding either.

\noindent 我喜欢后者，但你可以使用任何你喜欢的形式——任何人都不会有理解上的问题。

The formal definition of \index{logical equivalence}{\em logical equivalence}, 
which is what we've
been describing, is this:  two compound sentences are logically equivalent
if in a truth table (that contains all possible combinations of the 
truth values of the predicate variables in its rows) the truth values
of the two sentences are equal in every row.

我们一直在描述的\index{logical equivalence}{\em 逻辑等价}的正式定义是：如果在一个真值表（其行中包含谓词变量所有可能的真值组合）中，两个复合句的真值在每一行都相等，那么这两个复合句就是逻辑等价的。

\begin{exer} 
Consider the two compound sentences $A \lor B$ and $A \lor ({\lnot}A \land B)$.

考虑两个复合句 $A \lor B$ 和 $A \lor ({\lnot}A \land B)$。

There are a total of 2 predicate variables between them, so a truth table
with 4 rows will suffice.

它们之间总共有2个谓词变量，所以一个4行的真值表就足够了。

Fill out the missing entries in the truth
table and determine whether the statements are equivalent.

填写真值表中缺失的条目，并判断这两个陈述是否等价。

\begin{center}
\begin{tabular}{c|c||c|c}
\; $A$ \; & \; $B$ \; & \; $A \lor B$ \; & \; $A \lor ({\lnot}A \land B)$\; \\ \hline
T & T &  & \\
T & $\phi$ & & \\
 $\phi$ & T & &  \\
 $\phi$ &  $\phi$  & &\\
\end{tabular}
\end{center}

\end{exer}

One could, in principle, verify all logical equivalences by filling out
truth tables.

原则上，人们可以通过填写真值表来验证所有的逻辑等价。

Indeed, in the exercises for this section we will ask you
to develop a certain facility at this task.

实际上，在本节的练习中，我们将要求你培养完成这项任务的某种熟练度。

While this activity can
be somewhat fun, and many of my students want the filling-out of truth 
tables to
be a significant portion of their midterm exam, you will probably eventually
come to find it somewhat tedious.

虽然这项活动可能有些有趣，并且我的许多学生希望填写真值表成为他们期中考试的重要部分，但你可能最终会觉得它有些乏味。

A slightly more mature approach to logical
equivalences is this: use a set of basic equivalences -- which themselves
may be verified via truth tables -- as the basic {\em rules} or 
\index{laws of logical equivalence}{\em laws}
of logical equivalence, and develop a strategy for converting one
sentence into another using these rules.

一个对逻辑等价更成熟的方法是：使用一组基本的等价式——它们本身可以通过真值表来验证——作为逻辑等价的基本{\em 规则}或\index{laws of logical equivalence}{\em 定律}，并制定一种使用这些规则将一个句子转换为另一个句子的策略。

This process will feel very
familiar, it is like ``doing'' algebra, but the rules one is allowed 
to use are subtly different.

这个过程会感觉非常熟悉，它就像“做”代数，但允许使用的规则有细微的不同。

First we have the \index{commutative law}{\em commutative laws}, 
one each for conjunction
and disjunction.

首先，我们有\index{commutative law}{\em 交换律}，合取和析取各一个。

It's worth noting that there {\em isn't} a commutative
law for implication.

值得注意的是，蕴涵{\em 没有}交换律。

The commutative property of conjunction says that $A \land B \cong B \land A$.

合取的交换律表明 $A \land B \cong B \land A$。

This is quite an apparent statement from the perspective of linguistics.

从语言学的角度来看，这是一个非常明显的陈述。

Surely it's the same thing to say ``the weather is cold and snowy'' as it is to
say ``the weather is snowy and cold.''   
This commutative property is also clear 
from the perspective of digital logic circuits.

说“天气又冷又下雪”和说“天气又下雪又冷”当然是同一回事。这个交换律从数字逻辑电路的角度来看也很清楚。

\begin{center}
\input{figures/comm_conj.tex}
\end{center}   
  
The commutative property of disjunctions is equally transparent from
the perspective of a circuit diagram.

从电路图的角度来看，析取的交换律同样显而易见。

\begin{center}
\input{figures/comm_disj.tex}
\end{center}   
  
The \index{associative law}{\em associative laws} also have something to do with what order operations
are done.

\index{associative law}{\em 结合律}也与运算的顺序有关。

One could think of the difference in the following terms:  
Commutative properties
involve spatial or physical order and the associative properties involve
temporal order.

可以这样来思考它们的区别：交换律涉及空间或物理顺序，而结合律涉及时间顺序。

The associative law of addition could be used to say we'll
get the same result if we add 2 and 3 first, then add 4, or if we add 2 to the 
sum of 3 and 4 (i.e.\ that $(2+3)+4$ is the same as $2+(3+4)$.)  Note that 
physically, the numbers are in the same order (2 then 3 then 4) in both 
expressions but that the parentheses indicate a precedence in {\em when} the
plus signs are evaluated.

加法结合律可以用来表示，如果我们先将2和3相加，然后再加4，或者我们将2与3和4的和相加，我们会得到相同的结果（即 $(2+3)+4$ 与 $2+(3+4)$ 相同）。请注意，在两个表达式中，数字的物理顺序是相同的（2然后3然后4），但括号表明了加号被求值的{\em 时间}优先级。

The associative law of conjunction states that $A \land (B \land C) \cong
(A \land B) \land C$.

合取结合律表明 $A \land (B \land C) \cong (A \land B) \land C$。

In visual terms, this means the following two 
circuit diagrams are equivalent.

在视觉上，这意味着以下两个电路图是等价的。

\begin{center}
\input{figures/assoc_conj.tex}
\end{center}   
  
The associative law of disjunction states that $A \lor (B \lor C) \cong
(A \lor B) \lor C$.

析取结合律表明 $A \lor (B \lor C) \cong (A \lor B) \lor C$。

Visually, this looks like:

在视觉上，它看起来像：

\begin{center}
\input{figures/assoc_disj.tex}
\end{center}   
  

\begin{exer}
In a situation where {\em both} associativity and commutativity pertain
the symbols involved can appear in any order and with any reasonable 
parenthesization.

在{\em 同时}适用结合律和交换律的情况下，所涉及的符号可以以任何顺序出现，并带有任何合理的括号组合。

In how many different ways can the sum $2+3+4$ 
be expressed?  Only consider expression that are fully parenthesized.

和 $2+3+4$ 可以用多少种不同的方式表达？只考虑完全加括号的表达式。
\end{exer}
 
The next type of basic logical equivalences we'll consider are the
so-called \index{distributive law}{\em distributive laws}.

我们接下来要考虑的基本逻辑等价类型是所谓的\index{distributive law}{\em 分配律}。

Distributive laws involve the 
interaction of two operations, when we distribute multiplication 
over a sum, we effectively replace one instance of an operand {\em 
and the associated operator}, with two instances, as is illustrated
below.

分配律涉及两种运算的相互作用，当我们将乘法分配到加法上时，我们实际上是将一个操作数{\em 及其相关运算符}的一个实例替换为两个实例，如下所示。

\begin{center}
\input{figures/dist_2x3+4.tex}
\end{center}   
  
The logical operators $\land$ and $\lor$ each distribute over the other.

逻辑运算符 $\land$ 和 $\lor$ 彼此都具有分配性。

Thus we have the distributive law of conjunction over disjunction, which
is expressed in the equivalence 
$A \land (B \lor C) \cong (A \land B) \lor (A \land C)$ 
and in the following digital logic circuit diagram.

因此，我们有合取对析取的分配律，其表达式为等价式 $A \land (B \lor C) \cong (A \land B) \lor (A \land C)$，并由以下数字逻辑电路图表示。

\begin{center}
\input{figures/dist_and_o_or.tex}
\end{center}   

We also have the distributive law of disjunction over conjunction 
which is given by the equivalence 
$A \lor (B \land C) \cong (A \lor B) \land (A \lor C)$ and in the 
circuit diagram:

我们还有析取对合取的分配律，其等价式为 $A \lor (B \land C) \cong (A \lor B) \land (A \lor C)$，并由电路图表示：

\begin{center}
\input{figures/dist_or_o_and.tex}
\end{center}   

Traditionally, the laws we've just stated would be called 
{\em left}-distributive laws and we would also need to state 
that there are {\em right}-distributive laws that apply.

传统上，我们刚才陈述的定律被称为{\em 左}分配律，我们还需要说明同样适用{\em 右}分配律。

Since,
in the current setting, we have already said that the commutative
law is valid, this isn't really necessary.

由于在当前设定下，我们已经说过交换律是有效的，所以这并非完全必要。

\begin{exer}
State the right-hand versions of the distributive laws.

陈述分配律的右侧版本。
\end{exer}

The next set of laws we'll consider come from trying to
figure out what the distribution of a minus sign over a sum
($-(x+y) = -x + -y$)
should correspond to in Boolean algebra.

我们接下来要考虑的一组定律来自于试图弄清楚负号在和上的分配（$-(x+y) = -x + -y$）在布尔代数中应该对应什么。

At first blush one 
might assume the analogous thing in Boolean algebra would be
something like ${\lnot}(A \land B) \cong {\lnot}A \land {\lnot}B$,
but we can easily dismiss this by looking at a truth table.

乍一看，人们可能会认为布尔代数中的类似情况会是 ${\lnot}(A \land B) \cong {\lnot}A \land {\lnot}B$ 这样的东西，但我们可以通过查看真值表轻松地否定这一点。

\begin{center}
\begin{tabular}{c|c||c|c}
\; $A$ \; & \; $B$ \; & \; ${\lnot}(A \land B)$ \; & \; ${\lnot}A \land {\lnot}B$\; \\ \hline
T & T &  $\phi$ & $\phi$ \\
T & $\phi$ & T & $\phi$ \\
 $\phi$ & T & T & $\phi$ \\
 $\phi$ &  $\phi$  & T & T\\
\end{tabular}
\end{center}

What actually works is a set of rules known as 
\index{DeMorgan's laws}DeMorgan's laws, which
basically say that you distribute the negative sign but
you also must change the operator.

真正有效的是一套被称为\index{DeMorgan's laws}德摩根定律的规则，它基本上是说，你分配了否定号，但你也必须改变运算符。

As logical equivalences,
DeMorgan's laws are 

作为逻辑等价式，德摩根定律是：

\[ {\lnot}(A \land B) \; \cong \; {\lnot}A \lor {\lnot}B \]

\noindent and

\noindent 和

\[ {\lnot}(A \lor B) \; \cong \; {\lnot}A \land {\lnot}B. \]

In ordinary arithmetic there are two notions of ``inverse.''  The 
{\em negative} of a number is known as its additive inverse and
the {\em reciprocal} of a number is its multiplicative inverse.

在普通算术中，有两个“逆”的概念。一个数的{\em 负数}被称为它的加法逆元，一个数的{\em 倒数}是它的乘法逆元。

These notions lead to a couple of equations,

这些概念引出了几个方程：

\[ x + -x = 0 \]

\noindent and

\noindent 和

\[ x \cdot \frac{1}{x} = 1. \]

\noindent Boolean algebra only has one ``inverse'' concept, the denial
 of a predicate (i.e.\ logical negation), but the equations above have analogues, as do
the symbols $0$ and $1$ that appear in them.

\noindent 布尔代数只有一个“逆”的概念，即谓词的否定（即逻辑否定），但上面的方程有其类似物，方程中出现的符号0和1也是如此。

First, consider
the Boolean expression $A \lor {\lnot}A$.  This is the logical {\em or}
of a statement and its exact opposite;

首先，考虑布尔表达式 $A \lor {\lnot}A$。这是一个陈述与其完全相反的陈述的逻辑{\em 或}；

when one is true the other is 
false and vice versa.  But, the disjunction $A \lor {\lnot}A$, is 
always true!

当一个为真时，另一个为假，反之亦然。但是，析取式 $A \lor {\lnot}A$ 总是为真！

We use the symbol $t$ (which stands for 
\index{tautology}{\em tautology})
to represent a compound sentence whose truth value is always true.

我们使用符号 $t$（代表\index{tautology}{\em 重言式}）来表示一个真值总是为真的复合句。

A tautology ($t$) is to Boolean algebra something like a zero ($0$)
is to arithmetic.

重言式（$t$）对于布尔代数，就像零（$0$）对于算术一样。

Similar thinking about the Boolean expression
  $A \land {\lnot}A$ leads to the definition of the symbol $c$ (which
stands for \index{contradiction}{\em contradiction}) to 
represent a sentence that is always
false.

对布尔表达式 $A \land {\lnot}A$ 进行类似的思考，引出了符号 $c$（代表\index{contradiction}{\em 矛盾式}）的定义，用以表示一个总是为假的句子。

The rules we have been discussing are known as 
\index{complementarity laws}{\em complementarity laws}:

我们一直在讨论的规则被称为\index{complementarity laws}{\em 互补律}：

\[ A \lor {\lnot}A \; \cong \; t \mbox{\rule{12pt}{0pt} and \rule{12pt}{0pt}}
A \land {\lnot}A \; \cong \; c \]


Now that we have the special logical sentences represented by $t$ and $c$
we can present the so-called \index{identity laws}{\em identity laws}, 
$A \land t \cong A$ and
$A \lor c \cong A$.

现在我们有了由 $t$ 和 $c$ 代表的特殊逻辑句，我们可以介绍所谓的\index{identity laws}{\em 同一律}，$A \land t \cong A$ 和 $A \lor c \cong A$。

If you ``and'' a statement with something that is always
true, this new compound has the exact same truth values as the original.

如果你将一个陈述与一个总是为真的东西进行“与”运算，这个新的复合句与原始陈述具有完全相同的真值。

If you ``or'' a statement with something that is always false, the new compound
statement is also unchanged from the original.

如果你将一个陈述与一个总是为假的东西进行“或”运算，新的复合陈述也与原始陈述保持不变。

Thus performing a 
conjunction with a tautology has no effect -- sort of like multiplying by 1.
Performing a disjunction with a contradiction also has no effect -- this is
somewhat akin to adding 0. 

因此，与一个重言式进行合取运算没有效果——有点像乘以1。与一个矛盾式进行析取运算也没有效果——这有点像加上0。

The number 0 has a special property: $0 \cdot x = 0$ is an equation that 
holds no matter what $x$ is.

数字0有一个特殊的性质：$0 \cdot x = 0$ 是一个无论 $x$ 是什么都成立的方程。

This is known as a domination property.  Note 
that there isn't a dominance rule that involves 1.
 On the Boolean side, 
{\em both} the symbols $t$ and $c$ have related domination rules.

这被称为统治性。请注意，没有涉及1的统治规则。在布尔方面，{\em 两个}符号 $t$ 和 $c$ 都有相关的统治规则。

\[ A \lor t \cong t \mbox{\rule{12pt}{0pt} and \rule{12pt}{0pt}} 
A \land c \cong c \]
 
In mathematics the word \index{idempotent}{\em idempotent} is used to describe situations where 
the powers of a thing are equal to that thing.

在数学中，\index{idempotent}{\em 幂等}这个词用来描述一个东西的幂等于它自身的情况。

For example, because every power of $1$ {\em is} $1$, we say that $1$ is an idempotent.

例如，因为1的任何次幂{\em 都是}1，所以我们说1是幂等的。

Both of the Boolean operations 
have idempotence relations that just always work (regardless of the operand).

两个布尔运算都有幂等关系，这些关系总是成立（与操作数无关）。

In ordinary algebra idempotents are very rare ($0$ and $1$ are the only
ones that come to mind), but in Boolean algebra {\em every} statement
is equivalent to its square -- where the square of $A$ can be interpreted 
either as $A \land A$ or as $A \lor A$.

在普通代数中，幂等元素非常罕见（我能想到的只有0和1），但在布尔代数中，{\em 每个}陈述都等价于它的平方——其中$A$的平方可以解释为$A \land A$或$A \lor A$。

\[ A \lor A \cong A \mbox{\rule{12pt}{0pt} and \rule{12pt}{0pt}}% 
A \land A \cong A \]

There are a couple of properties of the logical negation operator 
that should be stated, though probably they seem self-evident.

逻辑否定算子有几个性质应该说明，尽管它们可能看起来不言自明。

If you form the denial of a denial, you come back to the 
same thing as the original;

如果你对一个否定进行否定，你会回到与原始事物相同的东西；

also the symbols $c$ and $t$ are negations
of one another.

另外，符号 $c$ 和 $t$ 互为否定。

\[ \lnot({\lnot}A) \cong A \mbox{\rule{12pt}{0pt} and \rule{12pt}{0pt}}% 
{\lnot}t  \cong c \] 

Finally, we should mention a really strange property, called 
\index{absorption}{\em absorption},
which states that the expressions $A \land (A \lor B)$ and $A \lor (A \land B)$
don't actually have anything to do with $B$ at all!

最后，我们应该提到一个非常奇怪的性质，称为\index{absorption}{\em 吸收律}，它表明表达式 $A \land (A \lor B)$ 和 $A \lor (A \land B)$ 实际上与 $B$ 根本没有任何关系！

Both of the preceding
statements are equivalent to $A$.

前面的两个陈述都等价于 $A$。

\[ A \land (A \lor B) \cong A \mbox{\rule{12pt}{0pt} and \rule{12pt}{0pt}}% 
A \lor (A \land B) \cong A \]

In Table~\ref{tab:bool_equiv}, we have collected all of these basic logical
equivalences in one place.

在表~\ref{tab:bool_equiv}中，我们将所有这些基本的逻辑等价式收集在了一起。

\begin{table}[hbt] 
\begin{center}
\input{logic-zh/logical_equivalences.tex}
\end{center} 
\caption{Basic logical equivalences. 基本逻辑等价式。}
\label{tab:bool_equiv}\index{rules of replacement}
\end{table}

\clearpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/le-exer.tex}

\newpage

\section{Two-column proofs 二列证明}
\label{sec:2_col}

If you've ever spent much time trying to check someone else's work
in solving an algebraic problem, you'd probably agree that it 
would be a help to know what they were \emph{trying} to do in each
step.

如果你曾花很多时间检查别人解决代数问题的工作，你可能会同意，了解他们在每一步中\emph{试图}做什么会有所帮助。

Most people have this fairly vague notion that they're allowed 
to ``do the same thing on both sides'' and they're allowed to simplify
the sides of the equation separately -- but more often than not, several
different things get done on a given line, mistakes get made, and it can
be nearly impossible to figure out what went wrong and where.

大多数人都有这样一个相当模糊的概念，即他们被允许“在两边做同样的事情”，并且他们被允许分别简化方程的两边——但更多时候，一行中会完成几件不同的事情，错误会发生，并且几乎不可能找出问题出在哪里。

Now, after all, the beauty of math is supposed to lie in its crystal clarity,
so this sort of situation is really unacceptable.

毕竟，数学的美妙之处应该在于其水晶般的清晰，所以这种情况实在令人无法接受。

It may be an impossible
goal to get ``the average Joe'' to perform algebraic manipulations with
clarity, but those of us who aspire to become mathematicians must certainly
hold ourselves to a higher standard.

让“普通人”清晰地进行代数操作可能是一个不可能实现的目标，但我们这些有志于成为数学家的人必须当然地以更高的标准要求自己。

\index{two-column proof}Two-column proofs are usually what 
is meant by a ``higher standard'' when we are talking about relatively
mechanical manipulations -- like doing algebra, or more to the point,
proving logical equivalences.

当我们谈论相对机械的操作时——比如做代数，或者更确切地说，证明逻辑等价——\index{two-column proof}二列证明通常就是所谓的“更高标准”。

Now don't despair!  You will not, in 
a mathematical career, be expected to provide two-column proofs very
often.

现在不要绝望！在数学职业生涯中，你不会被期望经常提供二列证明。

In fact, in more advanced work one tends to not give \emph{any} sort
of proof for a statement that lends itself to a two-column approach.

事实上，在更高级的工作中，对于一个适合二列证明方法的陈述，人们倾向于不提供\emph{任何}形式的证明。

But,
if you find yourself writing ``As the reader can easily verify, Equation~17 holds\ldots'' in a paper, or making some similar remark to your students,
you are \emph{morally obligated} to being able to produce a two-column proof.

但是，如果你发现自己在论文中写道“读者可以很容易地验证，方程17成立……”或者对你的学生发表类似的言论，你在\emph{道义上}有义务能够给出一个二列证明。

So what, exactly, is a two-column proof?  In the left column you show your 
work, being careful to go one step at a time.

那么，二列证明究竟是什么？在左栏，你展示你的工作，注意一次只走一步。

In the right column you
provide a justification for each step.

在右栏，你为每一步提供一个理由。

We're going to go through a couple of examples of two-column proofs 
in the context of proving logical equivalences.

我们将通过几个在证明逻辑等价背景下的二列证明的例子。

One thing to watch out
for: if you're trying to prove a given equivalence, and the first thing 
you write down is that very equivalence, \emph{it's wrong!}  This 
would constitute the logical error known as 
\index{begging the question}``begging the question'' 
also known as \index{circular reasoning}``circular reasoning.''  
It's clearly not okay to try
to demonstrate some fact by first \emph{asserting the very same fact}.

需要注意的一件事是：如果你试图证明一个给定的等价，而你写下的第一件事就是那个等价本身，\emph{那就错了！}这将构成被称为\index{begging the question}“窃取论题”或\index{circular reasoning}“循环论证”的逻辑谬误。试图通过首先\emph{断言同一事实}来证明某个事实，这显然是不行的。

Nevertheless, there is (for some unknown reason) a powerful temptation
to do this very thing.

然而，（出于某种未知的原因）人们有一种强烈的诱惑去做这件事。

To avoid making this error, we will not
put any equivalences on a single line.

为了避免犯这个错误，我们不会把任何等价式放在同一行。

Instead we will start with 
one side or the other of the statement to be proved, and modify it
using known rules of equivalence, until we arrive at the other side.

相反，我们将从待证陈述的一边开始，并使用已知的等价规则对其进行修改，直到我们到达另一边。

Without further ado, let's provide a proof of the equivalence  
$A \land (B \lor {\lnot}A) \; \cong \; A \land B $.\footnote{This equivalence should have been verified using truth tables in the exercises from the previous
section.}
\medskip

闲话少说，让我们来证明这个等价式 $A \land (B \lor {\lnot}A) \; \cong \; A \land B $。\footnote{这个等价应该已经在上一节的练习中用真值表验证过了。}
\medskip

\begin{center}
\begin{tabular}{p{2in}p{2in}}
\rule{10pt}{0pt} $A \land (B \lor {\lnot}A)$ & \\
 & distributive law (分配律)\\
$\cong (A \land B) \lor (A \land {\lnot}A)$ & \\
 & complementarity (互补律)\\
$\cong (A \land B) \lor c$ & \\
 & identity law (同一律)\\
$\cong (A \land B)$ & \\
\end{tabular}
\end{center}
\medskip

We have assembled a nice, step-by-step sequence of equivalences -- each
justified by a known law -- that begins with the left-hand side of the 
statement to be proved and ends with the right-hand side.

我们已经构建了一个很好的、逐步的等价序列——每一步都由一个已知的定律来证明——它从待证陈述的左边开始，到右边结束。

That's an 
irrefutable proof!

这是一个无可辩驳的证明！

In the next example we'll highlight a slightly sloppy habit of thought
that tends to be problematic.

在下一个例子中，我们将强调一个倾向于带来问题的、略显草率的思维习惯。

People usually (at first) associate a 
direction with the basic logical equivalences.

人们通常（起初）会将一个方向与基本的逻辑等价联系起来。

This is reasonable 
for several of them because one side is markedly simpler than the 
other.

对于其中几个来说，这是合理的，因为一边明显比另一边简单。

For example, the domination rule would normally be used
to replace a part of a statement that looked like ``$A \land c$'' with
the simpler expression ``$c$''.

例如，统治规则通常用于将陈述中看起来像“$A \land c$”的部分替换为更简单的表达式“$c$”。

There is a certain amount of strategization
necessary in doing these proofs, and I usually advise people to start 
with the more complicated side of the equivalence to be proved.

做这些证明需要一定的策略，我通常建议人们从待证等价式更复杂的一边开始。

It just
feels right to work in the direction of making things simpler, but there 
are times when one has to take one step back before proceeding two steps
forward\ldots   

朝着简化事物的方向努力感觉就是对的，但有时在前进两步之前必须先退一步……

Let's have a look at another equivalence: $A \land (B \lor C) \cong 
(A \land (B \lor C)) \lor (A \land C)$.

让我们看另一个等价式：$A \land (B \lor C) \cong (A \land (B \lor C)) \lor (A \land C)$。

There are many different ways
in which valid steps can be concatenated to convert one side of this 
equivalence into the other, so a subsidiary goal is to find a proof that
uses the least number of steps.

有很多不同的方法可以将这个等价式的一边通过有效的步骤串联转换为另一边，所以一个次要目标是找到使用最少步骤的证明。

Following my own advice, I'll start 
with the right-hand side of this one.

采纳我自己的建议，我将从这个等价式的右边开始。

\medskip

\begin{center}
\begin{tabular}{p{2in}p{2in}}
\rule{10pt}{0pt} $(A \land (B \lor C)) \lor (A \land C)$ & \\
 & distributive law (分配律)\\
$\cong  ((A \land B) \lor (A \land C)) \lor (A \land C)$ & \\
 & associative law (结合律)\\
$\cong  (A \land B) \lor ((A \land C) \lor (A \land C))$ & \\
 & idempotence (幂等律) \\
$\cong (A \land B) \lor (A \land C) $ & \\
 & distributive law (分配律)\\
$\cong A \land (B \lor C)$ & \\
\end{tabular}
\end{center}
\medskip

Note that in the example we've just done, the two applications
of the distributive law go in opposite directions as far as their
influence on the complexity of the expressions are concerned.

请注意，在我们刚刚完成的例子中，两次应用分配律在它们对表达式复杂性的影响方面，方向是相反的。

\clearpage

\noindent{\large \bf Exercises --- \thesection\ }


\input{logic-zh/2_col-exer.tex}


\newpage

\section{Quantified statements 量化陈述}
\label{sec:quant}

All of the statements discussed in the previous sections were of the 
``completely unambiguous'' sort;
that is, they didn't have any {\em unknowns}  
in them.

前面章节讨论的所有陈述都属于“完全无歧义”的类型；也就是说，它们里面没有任何{\em 未知数}。

As a reader of this text, it's a sure bet that you've mastered
Algebra and are firmly convinced of the utility of $x$ and $y$.

作为本书的读者，你肯定已经掌握了代数，并坚信 $x$ 和 $y$ 的功用。

Admittedly,
we've used variables to refer to sentences (or sentence fragments) themselves,
but we've said that sentences that had variables {\em in them} were ambiguous 
and didn't even deserve to be called logical statements.

诚然，我们已经使用变量来指代句子（或句子片段）本身，但我们曾说过，含有变量的句子是模糊的，甚至不配被称为逻辑陈述。

The notion 
of \index{quantification}{\em quantification} 
allows us to use the power of variables within a
sentence without introducing ambiguity.

\index{quantification}{\em 量化}的概念允许我们在句子中使用变量的力量而不会引入歧义。

Consider the sentence ``There are exactly 7 odd primes less than 20.''  
This sentence has some kind of ambiguity in it (because it doesn't mention
the primes explicitly) and yet it certainly seems to have a definite 
truth value!

考虑句子“小于20的奇素数恰好有7个。”这个句子有某种歧义（因为它没有明确提及这些素数），但它显然具有一个确定的真值！

The reason its truth value is known (by the way, it is T)
is that the sentence is quantified.

其真值已知的原因（顺便说一下，它是T）是该句子被量化了。

``X is an odd prime less than 20.'' 
is an ambiguous sentence, but ``There are exactly 7 distinct X's that
are odd primes less than 20.'' is not.

“X是小于20的奇素数。”是一个模糊的句子，但“恰好有7个不同的X是小于20的奇素数。”则不是。

This example represents a fairly
unusual form of quantification.  Usually, we take away the ambiguity
of a sentence having a variable in it by asserting one of two levels 
of quantification: ``this is true at least once'' or ``this is always true''.

这个例子代表了一种相当不寻常的量化形式。通常，我们通过断言两种量化水平之一来消除含有变量的句子的歧义：“这至少为真一次”或“这一直为真”。

We've actually seen the symbols ($\exists$ and $\forall$) for these 
concepts already (in Section~\ref{sec:scary}).

我们实际上已经在第~\ref{sec:scary}节中见过这些概念的符号（$\exists$ 和 $\forall$）。

An \index{open sentence}{\em open sentence} 
is one that has variables in it.

一个\index{open sentence}{\em 开放句}是含有变量的句子。

We represent 
open sentences using a sort of functional notation to show what
variables are in them.

我们使用一种函数式符号来表示开放句，以显示其中包含哪些变量。

Examples:

例子：

\begin{enumerate}

\item[i)] $P(x)$ = ``$2^{2^x}+1$ is a prime.''

$P(x)$ = “$2^{2^x}+1$ 是一个素数。”

\item[ii)] $Q(x,y)$ = ``$x$ is prime or $y$ is a divisor of $x$.''

$Q(x,y)$ = “$x$ 是素数或 $y$ 是 $x$ 的一个约数。”

\item[iii)] $L(f,c,l)$ = ``The function $f$ has limit $l$ at $c$, if 
and only if, 
for every positive number $\epsilon$, there is a positive number $\delta$ 
such that whenever $|x-c| < \delta$ it follows that $|f(x)-l| < \epsilon$.''  

$L(f,c,l)$ = “函数 $f$ 在 $c$ 处的极限为 $l$，当且仅当，对于每一个正数 $\epsilon$，都存在一个正数 $\delta$，使得只要 $|x-c| < \delta$ 就有 $|f(x)-l| < \epsilon$。”
\end{enumerate}

That last example certainly is a doozey!

最后一个例子确实很棘手！

At first glance it would appear
to have more than three variables in it, and indeed it does!

乍一看，它似乎包含超过三个变量，而事实确实如此！

In order of
appearance, we have $f$, $l$, $c$, $\epsilon$, $\delta$ and $x$ -- the 
last three variables that appear ($\epsilon$, $\delta$ and $x$) are said
to be \index{bound variables}{\em bound}.

按出现顺序，我们有 $f, l, c, \epsilon, \delta$ 和 $x$ ——最后出现的三个变量（$\epsilon, \delta$ 和 $x$）被称为\index{bound variables}{\em 约束变量}。

A variable in an open sentence is bound if it is in the
scope of a quantifier.

如果一个开放句中的变量在量词的作用域内，那么它就是约束的。

Bound variables don't need to be mentioned
in the argument list of the sentence.

约束变量不需要在句子的参数列表中提及。

Unfortunately, when sentences are
given in natural languages the quantification status of a variable may 
not be clear.

不幸的是，当句子以自然语言给出时，一个变量的量化状态可能不清楚。

For example in the third sentence above, the variable $\delta$
is easily seen to be in the scope of the quantifier $\exists$ because of the
words ``there is a positive number'' that precede it.

例如，在上面的第三个句子中，变量 $\delta$ 很容易被看作在量词 $\exists$ 的作用域内，因为它前面有“存在一个正数”这些词。

Similarly, $\epsilon$
is universally quantified ($\forall$) because the phrase ``for every positive
number'' appears before it.  What is the status of $x$?

类似地，$\epsilon$ 是全称量化的（$\forall$），因为它前面出现了短语“对于每一个正数”。那么 $x$ 的状态是什么？

Is it really bound?

它真的是约束的吗？

The answers to such questions may not be clear at first, but after some 
thought you should be able to decide that $x$ is universally quantified.

这些问题的答案起初可能不清楚，但经过一些思考，你应该能够确定 $x$ 是全称量化的。

\begin{exer} What word in example iii) indicates that $x$ is in the
scope of a $\forall$ quantifier?

在例 iii) 中，哪个词表明 $x$ 在 $\forall$ 量词的作用域内？
\end{exer}

It is not uncommon, in advanced Mathematics, to encounter compound sentences
involving dozens of variables and 4 or 5 levels of quantification.

在高等数学中，遇到包含数十个变量和4到5层量化的复合句并不少见。

Such 
sentences seem hopelessly complicated at first sight -- the key to 
understanding them is to determine each variable's quantification status
explicitly and to break things down into simpler sub-parts.

这样的句子乍一看似乎复杂得令人绝望——理解它们的关键是明确确定每个变量的量化状态，并将事物分解成更简单的子部分。

For instance, in understanding example iii) above, it might be
useful to define some new open sentences:

例如，在理解上面的例 iii) 时，定义一些新的开放句可能会很有用：

$D(x,c,\delta)$ = ``$|x-c| < \delta$''

$E(f,x,l,\epsilon)$ = ``$|f(x)-l| < \epsilon$''

\noindent Furthermore, it's often handy to replace an awkward phrase (such as 
``the limit of $f$ at $c$ is $l$'') with symbols when possible.

\noindent 此外，尽可能用符号替换一些拗口的短语（例如“$f$ 在 $c$ 处的极限是 $l$”）通常很方便。

Example iii) now looks like 

例 iii) 现在看起来像：

\[ \lim_{x\rightarrow c}f(x) = l \iff \forall \epsilon>0 \, \exists \delta>0 \, \forall x \, D(x,c,\delta) \implies E(f,x,l,\epsilon).
\]

The sentence $D(x,c,\delta)$ is usually interpreted as saying that
``$x$ is close to $c$'' (where $\delta$ tells you {\em how} close.)
The sentence $E(f,x,l,\epsilon)$ could be expressed informally as
``$f(x)$ is close to $l$'' (again, $\epsilon$ serves to make the 
word ``close'' more exact).

句子 $D(x,c,\delta)$ 通常被解释为“$x$ 接近 $c$”（其中 $\delta$ 告诉你{\em 有多}近）。句子 $E(f,x,l,\epsilon)$ 可以非正式地表达为“$f(x)$ 接近 $l$”（同样，$\epsilon$ 用来使“接近”这个词更精确）。

It's instructive to write this sentence one last time, {\em completely}
in symbols and without the abbreviations we created for saying
that $x$ is near $c$ and $f(x)$ is near $l$:

最后一次，{\em 完全}用符号写出这个句子，并且不使用我们为表达“$x$ 靠近 $c$”和“$f(x)$ 靠近 $l$”而创建的缩写，是很有启发性的：


$\displaystyle \lim_{x\rightarrow c}f(x) = l \iff \forall \epsilon>0 \, \exists 
\delta>0 \, \forall x \, (|x-c| < \delta) \implies (|f(x)-l| < \epsilon) $.

不夸张地说，培养阅读和理解这个象形文字（以及其他类似的）的能力，构成了实分析课程的前几周内容。

It would not be unfair to say that developing the facility to read,
and understand, this hieroglyph (and others like it) constitutes the 
first several weeks of a course in Real Analysis.

培养阅读和理解这个象形文字（以及其他类似的）的能力，构成了实分析课程的前几周内容，这样说并不为过。

Let us turn back to another of the examples (of an open sentence) from the
beginning of this section.

让我们回到本节开头（关于开放句的）另一个例子。

$P(x)$ = ``$2^{2^x}+1$ is a prime.''

$P(x)$ = “$2^{2^x}+1$ 是一个素数。”

In the 17th century, \index{Fermat, Pierre de}Pierre de Fermat 
made the conjecture\footnote{Fermat's 
more famous conjecture, that $x^n+y^n=z^n$ has no non-trivial integer solutions
if $n$ is an integer with $n>2$ was discovered after his death. } that 
$\forall x \in {\mathbb N}, P(x)$.

在17世纪，\index{Fermat, Pierre de}皮埃尔·德·费马提出了一个猜想\footnote{费马更著名的猜想，即如果 $n$ 是大于2的整数，$x^n+y^n=z^n$ 没有非平凡整数解，是在他去世后发现的。}，即 $\forall x \in {\mathbb N}, P(x)$。

No doubt, this seemed reasonable to Fermat
because the numbers given by this formula (they are called 
\index{Fermat numbers}Fermat numbers in
his honor) are all primes -- at first!

毫无疑问，这对费马来说似乎是合理的，因为由这个公式给出的数（为了纪念他，这些数被称为\index{Fermat numbers}费马数）最初都是素数！

Fermat numbers are conventionally
denoted with a subscripted letter F,  $F_n = 2^{2^n}+1$, the first five
Fermat numbers are prime.

费马数通常用带下标的字母F表示，$F_n = 2^{2^n}+1$，前五个费马数都是素数。

\begin{center}
$\displaystyle F_0 = 2^{2^0}+1 = 3$\\
$\displaystyle F_1 = 2^{2^1}+1 = 5$\\
$\displaystyle F_2 = 2^{2^2}+1 = 17$\\
$\displaystyle F_3 = 2^{2^3}+1 = 257$\\
$\displaystyle F_4 = 2^{2^4}+1 = 65537$\\
\end{center}
 
Fermat probably computed that $F_5=4294967297$, and we can well imagine
that he checked that this number was not divisible by any small primes.

费马可能计算出 $F_5=4294967297$，我们可以想象他检查了这个数不能被任何小的素数整除。

Of course, this was well before the development of effective computing
machinery, so we shouldn't blame Fermat for not noticing that
$4294967297 = 641 \cdot 6700417$.

当然，这远在有效计算机器发展之前，所以我们不应该因为费马没有注意到 $4294967297 = 641 \cdot 6700417$ 而责备他。

This remarkable feat of factoring 
can be replicated in seconds on a modern computer, however it was done
first by \index{Euler, Leonhard} Leonhard Euler in 1732!

这个卓越的因式分解壮举在现代计算机上几秒钟内就能复制，然而它最初是由\index{Euler, Leonhard}莱昂哈德·欧拉在1732年完成的！

There is quite a lot of literature 
concerning the primeness and/or compositeness of Fermat numbers.

关于费马数的素性或合性有相当多的文献。

So
far, all the Fermat numbers between $F_5$ and $F_{32}$ (inclusive) have
been shown to be composite.

到目前为止，所有介于 $F_5$ 和 $F_{32}$（含）之间的费马数都已被证明是合数。

One might be tempted to conjecture that
only the first five Fermat numbers are prime, however this temptation
should be resisted \ldots  

人们可能会倾向于猜想只有前五个费马数是素数，然而这种诱惑应该被抵制……

Let us set aside, for the moment, further questions about Fermat numbers.

让我们暂时搁置关于费马数的进一步问题。

Suppose we define the set $U$ (for `Universe') by $U=\{0,1,2,3,4\}$.

假设我们定义集合 $U$（代表‘全域’）为 $U=\{0,1,2,3,4\}$。

Then the assertion, ``$\forall x \in U, P(x)$.'' is certainly true.

那么，断言“$\forall x \in U, P(x)$”肯定是正确的。

You should note that the only variable in this sentence is $x$, and
that the variable is bound -- it is universally quantified.

你应该注意到，这个句子中唯一的变量是 $x$，并且这个变量是约束的——它是全称量化的。

Open sentences
that have all variables bound are {\em statements}.  It is possible 
(in principle, and in finite universes, in practice) to check the 
truth value of such sentences.

所有变量都被约束的开放句是{\em 命题}。检查这类句子的真值是可能的（原则上，在有限的全域中，实践上也是如此）。

Indeed, the sentence ``$\forall x \in U, P(x)$'' has the same logical content
as ``$P(0) \land P(1) \land P(2) \land P(3)  \land P(4)$''.

实际上，句子“$\forall x \in U, P(x)$”与“$P(0) \land P(1) \land P(2) \land P(3)  \land P(4)$”具有相同的逻辑内容。

Both happen to be
true, but the real point here is to note that a universally quantified sentence
can be thought of instead as a conjunction.

两者恰好都为真，但这里的真正要点是注意到一个全称量化的句子可以被看作是一个合取。

\begin{exer}
Define a new set $U$ by $U=\{0,1,2,3,4,5\}$.  
Write a sentence using disjunctions
that is equivalent to ``$\exists x \in U, {\lnot}P(x)$.''

定义一个新集合 $U$ 为 $U=\{0,1,2,3,4,5\}$。用析取写一个等价于“$\exists x \in U, {\lnot}P(x)$”的句子。
\end{exer}

Even when we are dealing with infinite universes, it is possible to
think of universally quantified sentences in terms of conjunctions,
and existentially quantified sentences in terms of disjunctions.

即使在处理无限全域时，也可以将全称量化的句子看作合取，将存在量化的句子看作析取。

For
example, a quick look at the graphs should be sufficient to convince you
that ``$ x > \ln x $'' is a sentence that is true for all $x$ values in
${\mathbb R}^+$.

例如，快速看一下图表就足以让你相信，“$ x > \ln x $”对于 ${\mathbb R}^+$ 中所有的 $x$ 值都是成立的句子。

There is a notation, reminiscent of so-called sigma notation
for sums, that can be used to express this universally quantified sentence as
a conjunction.

有一种让人想起所谓的求和西格玛符号的记法，可以用来将这个全称量化的句子表示为一个合取。

\[
\forall x \in {\mathbb R}^+, x > \ln x \; \cong \; \bigwedge_{x \in {\mathbb R}^+} x > \ln x
\]

A similar notation exists for disjunctions.

析取也有类似的符号。

Purely as an example, consider
the following problem from recreational math: Find a four digit number that
is an integer multiple of its reversal.

纯粹作为例子，考虑以下来自趣味数学的问题：找一个四位数，它是其反序数的整数倍。

(By reversal, we mean the four
digit number with the digits in the opposite order -- for example, the
reversal of 1234 is 4321.)  The sentence\footnote{This sentence uses what %
is commonly referred to as an ``abuse of notation'' in order to avoid an %
unnecessarily complex problem statement.
One should not necessarily %
avoid such abuses if one's readers can be expected to easily understand %
what is meant, any more than one should completely eschew the splitting %
of infinitives.}
that states that this question has a solution is

（所谓反序数，我们指的是数字顺序相反的四位数——例如，1234的反序数是4321。）陈述这个问题有解的句子是\footnote{这个句子使用了通常所说的“滥用符号”，以避免不必要地复杂化问题陈述。如果读者能够轻易理解其意，就不一定需要避免这种滥用，就像不应该完全避免分割不定式一样。}

\[
\exists abcd \in {\mathbb Z},  \exists k \in {\mathbb Z}, abcd = k\cdot dcba
\]

This could be expressed instead as the disjunction of 9000 statements, or more 
compactly as

这可以被表达为9000个陈述的析取，或者更紧凑地表示为

\[
\bigvee_{1000\leq abcd \leq 9999}  \exists k \in {\mathbb Z}, abcd = k\cdot dcba.
\]

\begin{exer} The existential statement above is true because $8712 = 4\cdot 2178$.
There is one other solution -- find it!

上面的存在性陈述是正确的，因为 $8712 = 4\cdot 2178$。还有另外一个解——找到它！
\end{exer}

An important, or at least useful, talent for a Mathematics student to develop
is the ability to negate quantified sentences.

对于一个数学专业的学生来说，培养否定量化句子的能力是一项重要，或者至少是有用的才能。

There are two major reasons for this:
the techniques known as proof by contradiction and proof by contraposition.

这主要有两个原因：被称为反证法和换质位证法的技巧。

The contrapositive of a conditional sentence is logically
equivalent to it.

条件句的逆否命题在逻辑上与原命题等价。

Many veteran proofwriters give newcomers the advice:

许多经验丰富的证明写作者给新手的建议是：

``If you get stuck, try writing down the contrapositive.''

“如果你卡住了，试试写下逆否命题。”

Writing down the contrapositive of a logical statement will often involve finding the
negation of a quantified sentence.

写下一个逻辑陈述的逆否命题通常会涉及找到一个量化句子的否定。

Proof by contradiction also requires you to be able to
negate a logical statement in order to even get started.

反证法也要求你能够否定一个逻辑陈述才能开始。

Let's try one.

我们来试一个。

Our universe of discourse\footnote{The Pep Boys -- Manny, Moe and %
Jack -- are hopefully known to some readers as the mascots of a chain %
of automotive supply stores.} 
will be $P = \{ \mbox{Manny}, \mbox{Moe}, \mbox{Jack} \}$.

我们的论域\footnote{Pep Boys——Manny、Moe和Jack——希望一些读者知道他们是一家汽车用品连锁店的吉祥物。}将是 $P = \{ \mbox{Manny}, \mbox{Moe}, \mbox{Jack} \}$。

Consider the sentence 
``$\forall x \in P, x\; \mbox{starts with M}$.''   The equivalent sentence
expressed conjunctively is 

考虑句子“$\forall x \in P, x\; \mbox{以M开头}$。”用合取形式表达的等价句子是

\begin{gather*} (\mbox{Manny starts with M}) \land \\
(\mbox{Moe starts with M}) \land \\
(\mbox{Jack starts with M}).
\end{gather*}

\noindent  The negation
of this sentence (by DeMorgan's law) is a disjunction:

\noindent 这个句子的否定（根据德摩根定律）是一个析取：

\begin{gather*}
(\mbox{Manny doesn't start with M}) \lor \\ 
(\mbox{Moe doesn't start with M}) \lor \\
(\mbox{Jack doesn't start with M})
\end{gather*}

\noindent Finally, this disjunction of three sentences can be converted into 
a single sentence, existentially quantified over $P$:

\noindent 最后，这个三个句子的析取可以转换为一个单一的句子，在 $P$ 上进行存在量化：

``$\exists x \in P, {\lnot}(x \, \mbox{starts with M})$.'' 

The discussion in the previous paragraphs justifies some laws of 
Logic which should be thought of as generalizations of DeMorgan's laws:

前面段落的讨论证明了一些逻辑定律，这些定律应被视为德摩根定律的推广：

\[ 
{\lnot}( \forall x \in U, P(x)) \; \cong \; \exists x \in U, {\lnot}P(x)
\]

\noindent and

\noindent 和

\[ 
{\lnot}( \exists x \in U, P(x)) \; \cong \; \forall x \in U, {\lnot}P(x).
\]

It's equally valid to think of these rules in a way that's divorced from
DeMorgan's laws.

以一种与德摩根定律无关的方式来思考这些规则同样是有效的。

To show that a universal sentence is {\em false}, it suffices
to show that an existential sentence involving a negation of the original is 
true.

要证明一个全称句是{\em 假}的，只需证明一个包含原句否定的存在句是真即可。

If someone announces that ``All the Pep boys name's start with M!'' you might counter that
with ``Uhhmmm\ldots What about Jack?''

如果有人宣称“所有Pep boy的名字都以M开头！”你可能会反驳说“嗯……那Jack呢？”

In other words, to show that it is not the case that every Pep boy's name starts
with `M', one only needs to demonstrate that there is a Pep boy (Jack) whose 
name doesn't start with `M'.

换句话说，要证明并非每个Pep boy的名字都以‘M’开头，只需证明有一个Pep boy（Jack）的名字不以‘M’开头即可。

\clearpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/quant-exer.tex}


\newpage

\section{Deductive reasoning and Argument forms 演绎推理与论证形式}
\label{sec:deduct}

Deduction \index{deduction}
is the process by which we determine new truths from old.

演绎\index{deduction}是我们从旧真理推断出新真理的过程。

It is sometimes claimed that nothing truly new can come from deduction, 
the truth of a statement that is arrived at by deductive processes was 
lying (perhaps hidden somewhat) within the hypotheses.

有时有人声称，演绎无法产生真正新的东西，通过演绎过程得出的陈述的真实性（可能有些隐藏地）早已存在于假设之中。

This claim is something
of a canard, as any Sherlock Holmes aficionado can tell you, the statements
that can sometimes be deduced from others can be remarkably surprising.

这个说法有点像谣言，任何福尔摩斯的爱好者都可以告诉你，有时从其他陈述中推导出的陈述可能非常令人惊讶。

A better
argument against deduction is that it is a relatively ineffective way for most 
human beings to discover new truths -- for that purpose inductive processes are
superior for the majority of us.

一个更好的反对演绎的论点是，对于大多数人来说，它是一种发现新真理的相对无效的方式——为此，归纳过程对我们大多数人来说更优越。

Nevertheless, if a chain of deductive reasoning
leading from known hypotheses to a particular conclusion can be exhibited, the truth
of the conclusion is \emph{unassailable}.

然而，如果能展示一条从已知假设到特定结论的演绎推理链，那么这个结论的真实性是\emph{不容置疑}的。

For this reason, mathematicians have 
latched on to deductive reasoning as \emph{the} tool for, if not discovering 
our theorems, communicating them to others.

因此，数学家们将演绎推理作为\emph{这个}工具，如果不是用来发现我们的定理，那就是用来与他人交流。

The word ``argument'' has a negative connotation for many people because 
it seems to have to do with {\em disagreement}.

“论证”这个词对许多人来说带有负面含义，因为它似乎与{\em 分歧}有关。

Arguments within mathematics
(as well as many other scholarly areas), while they may be impassioned, should
not involve discord.

数学（以及许多其他学术领域）中的论证，虽然可能充满激情，但不应涉及不和。

A mathematical argument is a sequence of logically
connected statements designed to produce {\em agreement} as to the validity
of a proposition.

一个数学论证是一系列逻辑上相连的陈述，旨在就一个命题的有效性达成{\em 一致}。

This ``design'' generally follows one of two possibilities,
inductive reasoning or deductive reasoning.

这种“设计”通常遵循两种可能性之一，归纳推理或演绎推理。

In an inductive argument 
a long list of premises is presented whose truths are considered to be
apparent to all, each of which provides evidence that the desired conclusion
is true.

在归纳论证中，会呈现一长串前提，这些前提的真实性被认为是显而易见的，每一个都为所期望的结论提供了证据。

So an \index{inductive argument}inductive argument represents a kind of statistical thing,
you have all these statements that are true each of which indicates that 
the conclusion is most likely true\ldots  A strong inductive argument
amounts to what attorneys call a ``preponderance of the evidence.''  
Occasionally
a person who has been convicted of a crime based on a preponderance of the 
evidence is later found to be innocent.

所以一个\index{inductive argument}归纳论证代表了一种统计性的东西，你所有这些为真的陈述都表明结论很可能是真的……一个强有力的归纳论证相当于律师所说的“证据优势”。偶尔，一个基于证据优势被定罪的人后来被发现是无辜的。

This usually happens when new evidence
is discovered that incontrovertibly proves (i.e.\ shows through deductive
means) that he or she cannot be guilty.

这通常发生在发现了新的证据，无可争议地证明（即通过演绎手段表明）他或她不可能是罪犯时。

In a nutshell: inductive arguments
can be wrong. 

简而言之：归纳论证可能是错误的。

In contrast a deductive argument can only turn out to be wrong under 
certain well-understood circumstances.

相比之下，一个演绎论证只有在某些被充分理解的情况下才可能出错。

Like an inductive argument, a \index{deductive argument}deductive argument 
is essentially just a
long sequence of statements;

像归纳论证一样，一个\index{deductive argument}演绎论证本质上只是一长串陈述；

but there is some additional structure.
The last statement in the list is the {\em conclusion} -- the statement
to be proved -- those occurring before it are known as 
\index{premise}{\em premises}.

但它有一些额外的结构。列表中的最后一个陈述是{\em 结论}——待证明的陈述——在它之前的被称为\index{premise}{\em 前提}。

Premises may be further subdivided into (at least) five sorts: axioms,
definitions, previously proved theorems, hypotheses and deductions.

前提可以进一步细分为（至少）五类：公理、定义、已证明的定理、假设和推论。

Axioms and definitions are often glossed
over, indeed, they often go completely unmentioned (but rarely {\em unused}) 
in a proof.

公理和定义常常被一带而过，实际上，它们在证明中常常完全不被提及（但很少被{\em 弃用}）。

In the interest of brevity this is quite appropriate, but 
conceptually, you should think of an argument as being based off of 
the axioms for the particular area you are working in, and its standard 
definitions.

为了简洁起见，这很合适，但从概念上讲，你应该把一个论证看作是基于你所研究的特定领域的公理及其标准定义。

A rote knowledge of all the other theorems proved up to
the one you are working with would generally be considered excessive, 
but completely memorizing the axioms and standard definitions of a field 
is essential.

死记硬背你正在研究的那个定理之前所有已证明的定理通常被认为是过分的，但完全记住一个领域的公理和标准定义是至关重要的。

\index{hypotheses}Hypotheses are a funny class of premises -- they are things
which can be assumed true for the sake of the current argument.

\index{hypotheses}假设是一类有趣的前提——它们是为了当前论证而可以假设为真的东西。

For
example, if the statement you are trying to prove is a conditional,
then the antecedent may be assumed true (if the antecedent is false,
then the conditional is automatically true!).

例如，如果你试图证明的陈述是一个条件句，那么前件可以被假设为真（如果前件为假，那么条件句自动为真！）。

You should always be
careful to list all hypotheses explicitly, and at the end of your 
proof make sure that each and every hypothesis got used somewhere 
along the way.

你应该总是小心地明确列出所有假设，并在证明结束时确保每一个假设都在过程中的某个地方被使用。

If a hypothesis really isn't necessary then you have
proved a more general statement (that's a good thing).

如果一个假设真的不是必需的，那么你就证明了一个更普遍的陈述（这是一件好事）。

Finally, deductions -- I should note that the conclusion is also a 
deduction -- obey a very strict rule: every deduction follows from
the premises that have already been written down (this includes
axioms and definitions that probably won't actually have been written,
hypotheses and all the deductions made up to this point) by one of the 
so-called \index{rules of inference}rules of inference.

最后，推论——我应该指出结论也是一个推论——遵守一个非常严格的规则：每一个推论都遵循已写下的前提（这包括可能实际上没有写出的公理和定义、假设以及到目前为止所做的所有推论），通过所谓的\index{rules of inference}推理规则之一得出。

Each of the rules of inference actually amounts to a logical tautology
that has been re-expressed as a sort of re-writing rule.

每一个推理规则实际上都相当于一个逻辑重言式，它被重新表述为一种重写规则。

Each rule
of inference will be expressed as a list of logical 
sentences that are assumed to be among the premises of the argument, 
a horizontal bar, followed by the symbol $\therefore$ (which is
usually voiced as the word ``therefore'') and then a new statement 
that can be placed among the deductions.

每个推理规则都将表示为一列逻辑句子，这些句子被假定为论证的前提，然后是一条横线，后面跟着符号$\therefore$（通常读作“因此”），最后是一个可以放在推论中的新陈述。

For example, one (very obvious) rule of inference is

例如，一个（非常明显的）推理规则是

\begin{center}
\begin{tabular}{cl}
 & $A \land B$ \\ \hline
$\therefore$ & $B$\\
\end{tabular}
\end{center}
  
\noindent This rule is known as 
\index{conjunctive simplification}\emph{conjunctive simplification}, and
is equivalent to the tautology $(A \land B) \implies B$.

\noindent 这条规则被称为\index{conjunctive simplification}\emph{合取简化}，并且等价于重言式 $(A \land B) \implies B$。

The \index{modus ponens}\emph{modus ponens} 
rule\footnote{Latin for ``method of affirming'',
the related \emph{modus tollens} rule means ``method of denying.'' } 
is one of the most useful.

\index{modus ponens}\emph{肯定前件}规则\footnote{拉丁语，意为“肯定法”，相关的\emph{modus tollens}规则意为“否定法”。}是最有用的规则之一。

\begin{center}
\begin{tabular}{cl}
 & $A$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & $B$ \\
\end{tabular}
\end{center}

Modus ponens is related to the tautology $(A \land (A \implies B)) \implies B$.

肯定前件与重言式 $(A \land (A \implies B)) \implies B$ 相关。

\index{modus tollens}\emph{Modus tollens} 
is the rule of inference we get if we put modus ponens 
through the ``contrapositive'' wringer.

如果我们把肯定前件通过“逆否”转换，我们得到的推理规则是\index{modus tollens}\emph{否定后件}。

\begin{center}
\begin{tabular}{cl}
 & ${\lnot}B$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & ${\lnot}A$ \\
\end{tabular}
\end{center}

Modus tollens is related to the tautology $({\lnot}B \land (A \implies B)) \implies {\lnot}A$.

否定后件与重言式 $({\lnot}B \land (A \implies B)) \implies {\lnot}A$ 相关。

Modus ponens and modus tollens are also known as 
\index{syllogism}\emph{syllogisms}.

肯定前件和否定后件也被称为\index{syllogism}\emph{三段论}。

A 
syllogism is an argument form wherein a deduction follows from two premises.

三段论是一种论证形式，其中一个推论从两个前提得出。

There are two other common syllogisms, 
\index{hypothetical syllogism}\emph{hypothetical syllogism} and
\index{disjunctive syllogism}\emph{disjunctive syllogism}.

还有另外两种常见的三段论，\index{hypothetical syllogism}\emph{假言三段论}和\index{disjunctive syllogism}\emph{选言三段论}。

Hypothetical syllogism basically asserts a transitivity property for 
implications.

假言三段论基本上断言了蕴涵的传递性。

\begin{center}
\begin{tabular}{cl}
 & $A \implies B$ \\
 & $B \implies C$ \\ \hline
$\therefore$ & $A \implies C$ \\
\end{tabular}
\end{center}

Disjunctive syllogism can be thought of as a statement about
alternatives, but be careful to remember that in Logic, the disjunction
always has the inclusive sense.

选言三段论可以被看作是关于备选项的陈述，但要记住，在逻辑学中，析取总是具有相容的意义。

\begin{center}
\begin{tabular}{cl}
 & $A \lor B$ \\
 & ${\lnot}B$ \\ \hline
$\therefore$ & $A$ \\
\end{tabular}
\end{center}

\begin{exer}
Convert the $A \lor B$ that appears in the premises of the disjunctive
syllogism rule into an equivalent conditional.

将选言三段论规则前提中出现的 $A \lor B$ 转换为一个等价的条件句。

How is the new argument
form related to modus ponens and/or modus tollens?

新的论证形式与肯定前件和/或否定后件有何关系？
\end{exer}
 
The word ``dilemma'' usually refers to a situation in which an individual
is faced with an impossible choice.

“困境”这个词通常指一个人面临无法选择的境地。

A cute example known as the 
\index{Crocodile's dilemma}Crocodile's dilemma is as follows:

一个被称为\index{Crocodile's dilemma}鳄鱼困境的可爱例子如下：

\begin{quote}
A crocodile captures a little boy who has strayed too near the river.

一只鳄鱼抓住了一个离河太近的小男孩。

The 
child's father appears and the crocodile tells him ``Don't worry, I shall 
either release your son or I shall eat him.

孩子的父亲出现了，鳄鱼告诉他：“别担心，我要么放了你的儿子，要么吃掉他。

If you can say, in advance,
which I will do, then I shall release him.''  The father responds, ``You will
eat my son.''  What should the crocodile do?

如果你能提前说出我会怎么做，那我就放了他。”父亲回答说：“你会吃掉我的儿子。”鳄鱼应该怎么做？
\end{quote} 

In logical arguments the word dilemma is used in another sense having to
do with certain rules of inference.

在逻辑论证中，困境这个词在另一个意义上使用，与某些推理规则有关。

\index{constructive dilemma}\emph{Constructive dilemma} is 
a rule of inference having to do with the conclusion that one of two 
possibilities must hold.

\index{constructive dilemma}\emph{构造性二难}是一条推理规则，其结论是两种可能性之一必定成立。

\begin{center}
\begin{tabular}{cl}
 & $A \implies B$ \\
 & $C \implies D$ \\ 
 & $A \lor C$ \\ \hline
$\therefore$ & $B \lor D$ \\
\end{tabular}
\end{center}

\index{destructive dilemma}\emph{Destructive dilemma} 
is often not listed among the rules
of inference because it can easily be obtained by using the constructive
dilemma and replacing the implications with their contrapositives.

\index{destructive dilemma}\emph{破坏性二难}常常不被列入推理规则之中，因为它可以通过使用构造性二难并用蕴涵的逆否命题替换它们来轻松得到。

\begin{center}
\begin{tabular}{cl}
 & $A \implies B$ \\
 & $C \implies D$ \\ 
 & ${\lnot}B \lor {\lnot}D$ \\ \hline
$\therefore$ & ${\lnot}A \lor {\lnot}C$ \\
\end{tabular}
\end{center}

In Table~\ref{tab:roi}, the ten most common 
\index{rules of inference}rules of inference are listed.

在表~\ref{tab:roi}中，列出了十条最常见的\index{rules of inference}推理规则。

Note that all of these are equivalent to tautologies that
involve conditionals (as opposed to biconditionals), every one of the 
basic logical equivalences that we established in Section~\ref{sec:le}
is really a tautology involving a biconditional, collectively these are
known as the \index{rules of replacement}``rules of replacement.''  
In an argument, any statement
allows us to infer a logically equivalent statement.

请注意，所有这些都等价于涉及条件句（而非双条件句）的重言式，我们在第~\ref{sec:le}节中建立的每一个基本逻辑等价式实际上都是一个涉及双条件句的重言式，它们统称为\index{rules of replacement}“替换规则”。在一个论证中，任何陈述都允许我们推断出一个逻辑上等价的陈述。

Or, put differently,
we could replace any premise with a different, but logically equivalent,
premise.

或者，换句话说，我们可以用一个不同但逻辑上等价的前提来替换任何前提。

You might enjoy trying to determine a minimal set of rules of
inference, that together with the rules of replacement would allow one
to form all of the same arguments as the ten rules in Table~\ref{tab:roi}.

你可能会喜欢尝试确定一个最小的推理规则集，它与替换规则一起，可以让你形成与表~\ref{tab:roi}中十条规则相同的所有论证。

\begin{table}[hbt] 
\begin{center}
\begin{tabular}{c|c}
Name (名称) & Form (形式) \\ \hline
 & \\
Modus ponens (肯定前件) \rule{12pt}{0pt} &   
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & $B$ \\
\end{tabular} \\
 & \\ \hline
 & \\
Modus tollens (否定后件) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & ${\lnot}B$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & ${\lnot}A$ \\
\end{tabular}  \\ 
 & \\ \hline
 & \\
Hypothetical syllogism (假言三段论) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A \implies B$ \\
 & $B \implies C$ \\ \hline
$\therefore$ & $A \implies C$ \\
\end{tabular} \\ 
 & \\ \hline 
 & \\
Disjunctive syllogism (选言三段论) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A \lor B$ \\
 & ${\lnot}B$ \\ \hline
$\therefore$ & $A$ \\
\end{tabular}  \\ 
 & \\ \hline 
 & \\
Constructive dilemma (构造性二难) \rule{12pt}{0pt} & 
\rule{24pt}{0pt} \begin{tabular}{cl}
 & $A \implies B$ \\
 & $C \implies D$ \\ 
 & $A \lor C$ \\ \hline
$\therefore$ & $B \lor D$ \\
\end{tabular} \\
 & \\ 
\end{tabular}
\end{center}
\caption{The rules of inference. 推理规则。}
\label{tab:roi}
\end{table}
\clearpage

\rule{0pt}{0pt}

\vspace{.4in}

\begin{center}
\begin{tabular}{c|c}
Name (名称) & Form (形式) \\ \hline
 & \\
Destructive dilemma (破坏性二难) \rule{12pt}{0pt} & 
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A \implies B$ \\
 & $C \implies D$ \\ 
 & ${\lnot}B \lor {\lnot}D$ \\ \hline
$\therefore$ & ${\lnot}A \lor {\lnot}C$ \\
\end{tabular} \\ 
 & \\ \hline
 & \\
Conjunctive simplification (合取简化) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A \land B$ \\ \hline
$\therefore$ & $A$ \\
\end{tabular} \\ 
 & \\ \hline
 & \\
Conjunctive addition (合取附加) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A$ \\
 & $B$ \\ \hline
$\therefore$ & $A \land B$ \\
\end{tabular}  \\ 
 & \\ \hline
 & \\
Disjunctive addition (析取附加) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A$ \\ \hline
$\therefore$ & $A \lor B$ \\
\end{tabular} \\ 
 & \\ \hline
 & \\
Absorption (吸收律) \rule{12pt}{0pt} &
\rule{24pt}{0pt}\begin{tabular}{cl}
 & $A \implies B$ \\ \hline
$\therefore$ & $A \implies (A \land B)$ \\
\end{tabular}  \\ 
 & \\
\end{tabular}

\vspace{.25in}

Table~\ref{tab:roi}: The rules of inference.
(continued)

表~\ref{tab:roi}：推理规则。（续）
\index{rules of inference}
\end{center}


\newpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/deduct-exer.tex}

\newpage

\section{Validity of arguments and common errors 论证的有效性与常见错误}
\label{sec:valid}

An argument is said to be \emph{valid} or to have a 
\index{valid argument form}\emph{valid form} 
if each deduction in it can be justified with one of the rules
of inference listed in the previous section.

如果一个论证中的每个推论都可以用上一节列出的推理规则之一来证明，那么这个论证就被称为\emph{有效的}或具有\index{valid argument form}\emph{有效的形式}。

The \emph{form} of 
an argument might be valid, but still the conclusion may be false
if some of the premises are false.

一个论证的\emph{形式}可能是有效的，但如果某些前提是错误的，其结论仍然可能是错误的。

So to show that an argument is
good we have to be able to do two things: show that the argument 
is \emph{valid} (i.e.\ that every step can be justified) and that 
the argument is 
\index{soundness (of an argument)}\emph{sound} 
which means that all the premises are
true.

所以要证明一个论证是好的，我们必须能够做两件事：证明论证是\emph{有效的}（即每一步都可以被证明是正当的），并且论证是\index{soundness (of an argument)}\emph{可靠的}，这意味着所有的前提都是真的。

If you start off with a false premise, you can prove \emph{anything}!

如果你从一个错误的前提出发，你可以证明\emph{任何事情}！

Consider, for example the following ``proof'' that $2=1$.

例如，思考下面这个证明 $2=1$ 的“证明”。
\begin{quote}
  Suppose that $a$ and $b$ are two real numbers such that $a=b$.
  
  假设 $a$ 和 $b$ 是两个相等的实数，即 $a=b$。
  
\begin{center}
\begin{tabular}{p{2in}p{2in}}
 & by hypothesis, $a$ and $b$ are equal, so (根据假设, a和b相等, 所以)\\
 $a^2 = ab$ & \\
 & subtracting $b^2$ from both sides (两边同时减去b²)\\
 $a^2 - b^2 = ab - b^2$& \\
 & factoring both sides (两边同时因式分解)\\
 $(a+b)(a-b) = b(a-b)$ & \\
 & canceling $(a-b)$ from both sides (两边同时消去(a-b))\\
 $a+b = b$ & \\
\end{tabular}
\end{center}
\medskip
Now let $a$ and $b$ both have a particular value, $a=b=1$,
and we see that $1+1=1$, i.e.\ $2=1$.

现在让 $a$ 和 $b$ 都取一个特定的值，$a=b=1$，我们得到 $1+1=1$，即 $2=1$。
\end{quote}

This argument is not sound (thank goodness!) because one of the
premises -- actually the bad premise appears as one of the 
justifications of a step -- is false.

这个论证是不可靠的（谢天谢地！），因为其中一个前提——实际上，这个错误的前提是作为一个步骤的理由出现的——是错误的。

You can argue with
perfect logic to achieve complete nonsense if you include 
false premises.

如果你包含错误的前提，你可以用完美的逻辑论证出完全荒谬的结论。

\begin{exer}
It is \emph{not} true that you can always cancel the same thing from 
both sides of an equation.

你并非\emph{总是}可以从等式两边消去相同的东西，这句话是不对的。

Under what circumstances is such cancellation
disallowed?

在什么情况下不允许这样的消去？
\end{exer}

So, how can you tell if an argument has a valid form?

那么，你如何判断一个论证是否具有有效的形式呢？

Use a truth table.

使用真值表。

As an example, we'll verify that the rule of inference known as 
\index{destructive dilemma}``destructive dilemma'' 
is valid using a truth table.

作为一个例子，我们将使用真值表来验证被称为\index{destructive dilemma}“破坏性二难”的推理规则是有效的。

This argument
form contains 4 predicate variables so the truth table will have 16 rows.

这个论证形式包含4个谓词变量，所以真值表将有16行。

There is a column for each of the variables, the premises of the argument
and its conclusion.

表中每一列分别对应每个变量、论证的前提及其结论。

\begin{center}
\begin{tabular}{cccc|c|c|c|c|}
$A$   & $B$   & $C$   & $D$   & $A{\implies}B$ & $C{\implies}D$ & ${\lnot}B \lor {\lnot}D$ & ${\lnot}A \lor {\lnot}C$ \\ \hline
T     & T     & T     & T     & T     & T     & $\phi$ & $\phi$ \\
T     & T     & T     & $\phi$ & T     & $\phi$ & T     & $\phi$ \\
T     & T     & $\phi$ & T     & T     & T     & $\phi$ & T     \\
T     & T     & $\phi$ & $\phi$ & T     & T     & T     & T     \\
T     & $\phi$ & T     & T     & $\phi$ & T     & T     & $\phi$ \\
T     & $\phi$ & T     & $\phi$ & $\phi$ & $\phi$ & T     & $\phi$ \\
T     & $\phi$ & $\phi$ & T     & $\phi$ & T     & T     & T     \\
T     & $\phi$ & $\phi$ & $\phi$ & $\phi$ & T     & T     & T     \\ 
$\phi$ & T     & T     & T     & T     & T     & $\phi$ & T     \\
$\phi$ & T     & T     & $\phi$ & T     & $\phi$ & T     & T     \\
$\phi$ & T     & $\phi$ & T     & T     & T     & $\phi$ & T     \\
$\phi$ & T     & $\phi$ & $\phi$ & T     & T     & T     & T     \\
$\phi$ & $\phi$ & T     & T     & T     & T     & T     & T     \\
$\phi$ & $\phi$ & T     & $\phi$ & T     & $\phi$ & T     & T     \\
$\phi$ & $\phi$ & $\phi$ & T     & T     & T     & T     & T     \\
$\phi$ & $\phi$ & $\phi$ & $\phi$ & T     & T     & T     & T     \\
\end{tabular}
\end{center}

Now, mark the lines in which all of the premises of this argument form 
are true.  You should note that {\em in every single situation in which 
all the premises are true} the conclusion is also true.

现在，标记出这个论证形式所有前提都为真的行。你应该注意到，{\em 在所有前提都为真的每一种情况下}，结论也为真。

That's what 
makes ``destructive dilemma'' -- and all of its friends -- a rule of 
inference.

这就是为什么“破坏性二难”——以及它所有的同类规则——成为一条推理规则的原因。

Whenever all the premises are true so is the conclusion.

每当所有前提都为真时，结论也为真。

You should also notice that there are several rows in which the 
conclusion is true but some one of the premises isn't.

你还应该注意到，有几行中结论为真，但某个前提不为真。

That's
okay too, isn't it reasonable that the conclusion of an argument 
can be true, but at the same time the particulars of the argument 
are unconvincing?

那也没关系，一个论证的结论可以为真，但同时其论证细节却不具说服力，这难道不合理吗？

As we've noted earlier, an argument by deductive reasoning can go wrong 
in only certain well-understood ways.

正如我们之前指出的，一个演绎推理的论证只可能以某些被充分理解的方式出错。

Basically, either the form of the 
argument is invalid, or at least one of the premises is false.

基本上，要么是论证的形式无效，要么是至少有一个前提是错误的。

Avoiding 
false premises in your arguments can be trickier than it sounds -- many 
statements that sound appealing or intuitively clear are actually
counter-factual.

在你的论证中避免错误的前提可能比听起来要棘手——许多听起来很有吸引力或直觉上很清晰的陈述实际上是与事实相反的。

The other side of the coin, being sure that the 
\index{form (of an argument)}\emph{form} 
of your argument is valid, seems easy enough -- just be 
sure to only use the rules of inference as found in Table~\ref{tab:roi}.

另一方面，确保你的论证\index{form (of an argument)}\emph{形式}有效似乎足够简单——只需确保只使用表~\ref{tab:roi}中找到的推理规则。

Unfortunately most arguments that you either read or write
will be in prose, rather than appearing as a formal list of deductions.

不幸的是，你阅读或写作的大多数论证都将是散文形式，而不是作为正式的推论列表出现。

When dealing with that setting -- using natural rather than formalized 
language -- making errors in form is quite common.

在那种情况下——使用自然语言而非形式化语言——形式上的错误是相当普遍的。

Two invalid forms are usually singled out for criticism, the 
\index{converse error}\emph{converse error} and the 
\index{inverse error}\emph{inverse error}.

两种无效的形式通常被特别挑出来批评，即\index{converse error}\emph{逆命题错误}和\index{inverse error}\emph{否命题错误}。

In some sense 
these two apparently different ways to screw up are really the same thing.

在某种意义上，这两种看起来不同的搞砸方式实际上是同一回事。

Just as a conditional statement and its contrapositive are known to be 
equivalent, so too are the other related statements -- the
converse and the inverse -- equivalent.

正如一个条件陈述及其逆否命题是等价的一样，其他相关的陈述——逆命题和否命题——也是等价的。

The converse error consists of 
mistaking the implication in a modus ponens form for its converse.

逆命题错误在于将肯定前件式中的蕴涵误认为其逆命题。

The converse error:

逆命题错误：

\begin{center}
\begin{tabular}{cl}
 & $B$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & $A$ \\
\end{tabular}
\end{center}
   
Consider, for a moment the following argument.

暂时思考一下下面的论证。
\begin{quote}
If a rhinoceros sees something on fire, it will stomp on it. \newline
A rhinoceros stomped on my duck. \newline
Therefore, the rhino must have thought that my duck was on fire.
\index{duck, flaming}

如果一只犀牛看到有东西着火，它会去踩灭它。\newline
一只犀牛踩了我的鸭子。\newline
因此，那只犀牛一定以为我的鸭子着火了。
\end{quote} 

It \emph{is} true that rhinoceroses have an instinctive desire to extinguish 
fires.

犀牛确实有扑灭火灾的本能欲望。

Also, we can well imagine that if someone made this ridiculous 
argument that their duck must actually have been crushed by a rhino.

此外，我们可以想象，如果有人提出这个荒谬的论点，他们的鸭子肯定真的被犀牛踩扁了。

But, 
is the conclusion that the duck was on fire justified?

但是，鸭子着火了这个结论是合理的吗？

Not really, what 
the first part of the argument asserts is that ``(on fire) implies (rhino 
stomping)'' but couldn't a rhino stomp on something for other reasons?

不尽然，论证的第一部分断言的是“(着火) 蕴涵 (犀牛踩踏)”，但犀牛难道不会因为其他原因踩东西吗？

Perhaps the rhino was just ill-tempered.  Perhaps the duck was just 
horrifically unlucky.

也许那只犀牛只是脾气不好。也许那只鸭子只是倒霉透顶。

The closer the conditional is to being a biconditional, the more reasonable 
sounding is an argument exhibiting the converse error.

条件句越接近双条件句，表现出逆命题错误的论证听起来就越合理。

Indeed, if the 
argument actually contains a biconditional, the ``converse error'' is not 
an error at all.

实际上，如果论证中确实包含一个双条件句，那么“逆命题错误”就根本不是错误。

The following is a perfectly valid argument, that (sadly) has a false premise.

下面是一个完全有效的论证，但（遗憾的是）它有一个错误的前提。
\begin{quote}
You will get an A in your Foundations class if and only if you 
read Dr.\ Fields' book.\newline
You read Dr.\ Fields' book. \newline
Therefore, you will get an A in Foundations.

你将在你的基础课上获得A，当且仅当你阅读菲尔兹博士的书。\newline
你阅读了菲尔兹博士的书。\newline
因此，你将在基础课上获得A。
\end{quote}

Suppose that we try changing the major premise of that last argument to
something more believable.

假设我们试着将上一个论证的大前提改成更可信的内容。
\begin{quote}
If you read Dr.\ Fields' book, you will pass your Foundations class. \newline
You did not read Dr.\ Fields' book. \newline
Therefore, you will not pass Foundations.

如果你读了菲尔兹博士的书，你就会通过你的基础课。\newline
你没有读菲尔兹博士的书。\newline
因此，你不会通过基础课。
\end{quote}

This last argument exhibits the so-called \emph{inverse error}.

这最后一个论证表现了所谓的\emph{否命题错误}。

It is by 
no means meant as a guarantee, but nevertheless, it seems reasonable that 
if someone reads this book they will pass a course on this material.

这绝不是一种保证，但尽管如此，如果有人读了这本书，他们通过这门课程似乎是合理的。

The second premise is also easy to envision as true, although the
``you'' that it refers to obviously isn't \emph{you}, because \emph{you} 
are reading this book!

第二个前提也很容易被想象为真，尽管它所指的“你”显然不是\emph{你}，因为\emph{你}正在读这本书！

But even if we accept the premises as true, the 
conclusion doesn't follow.

但即使我们接受这些前提为真，结论也无法得出。

A person might have read some other book that 
addressed the requisite material in an exemplary way.

一个人可能读了另一本以典范方式讲解了所需材料的书。

Notice that the names for these two errors are derived from the change 
that would have to be made to convert them to modus ponens.

请注意，这两种错误的名称源于将它们转换为肯定前件式所需做的改变。

For example, 
the inverse error is depicted formally by:

例如，否命题错误在形式上被描述为：

\begin{center}
\begin{tabular}{cl}
 & ${\lnot}A$ \\
 & $A \implies B$ \\ \hline
$\therefore$ & ${\lnot}B$ \\
\end{tabular}
\end{center}

If we replaced the conditional in this argument form by its {\em inverse} 
(${\lnot}A \implies {\lnot}B$) then the revised argument would be 
modus ponens.

如果我们用它的{\em 否命题} (${\lnot}A \implies {\lnot}B$) 替换这个论证形式中的条件句，那么修改后的论证将是肯定前件式。

Similarly, if we replace the conditional in an
argument that suffers from the converse error by its converse, 
we'll have modus ponens.

类似地，如果我们将一个犯了逆命题错误的论证中的条件句替换为其逆命题，我们就会得到肯定前件式。
\clearpage

\noindent{\large \bf Exercises --- \thesection\ }

\input{logic-zh/valid-exer.tex}

%\newpage
%\renewcommand{\bibname}{References for chapter 2}
%\bibliographystyle{plain}
%\bibliography{GIAM}



%% Emacs customization
%% 
%% Local Variables: ***
%% TeX-master: "GIAM.tex" ***
%% comment-column:0 ***
%% comment-start: "%% "  ***
%% comment-end:"***" ***
%% End: ***